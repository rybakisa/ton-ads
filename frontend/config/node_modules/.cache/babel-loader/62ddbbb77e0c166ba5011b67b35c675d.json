{"ast":null,"code":"import Transport from \"@ledgerhq/hw-transport\";\nimport hidFraming from \"@ledgerhq/devices/lib/hid-framing\";\nimport { identifyUSBProductId } from \"@ledgerhq/devices\";\nimport { log } from \"@ledgerhq/logs\";\nimport { TransportOpenUserCancelled, TransportInterfaceNotAvailable, TransportWebUSBGestureRequired, DisconnectedDeviceDuringOperation, DisconnectedDevice } from \"@ledgerhq/errors\";\nimport { getLedgerDevices, getFirstLedgerDevice, requestLedgerDevice, isSupported } from \"./webusb\";\nconst configurationValue = 1;\nconst endpointNumber = 3;\n/**\n * WebUSB Transport implementation\n * @example\n * import TransportWebUSB from \"@ledgerhq/hw-transport-webusb\";\n * ...\n * TransportWebUSB.create().then(transport => ...)\n */\n\nexport default class TransportWebUSB extends Transport {\n  constructor(device, interfaceNumber) {\n    super();\n    this.device = void 0;\n    this.deviceModel = void 0;\n    this.channel = Math.floor(Math.random() * 0xffff);\n    this.packetSize = 64;\n    this.interfaceNumber = void 0;\n    this._disconnectEmitted = false;\n\n    this._emitDisconnect = e => {\n      if (this._disconnectEmitted) return;\n      this._disconnectEmitted = true;\n      this.emit(\"disconnect\", e);\n    };\n\n    this.exchange = apdu => this.exchangeAtomicImpl(async () => {\n      const {\n        channel,\n        packetSize\n      } = this;\n      log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n      const framing = hidFraming(channel, packetSize); // Write...\n\n      const blocks = framing.makeBlocks(apdu);\n\n      for (let i = 0; i < blocks.length; i++) {\n        await this.device.transferOut(endpointNumber, blocks[i]);\n      } // Read...\n\n\n      let result;\n      let acc;\n\n      while (!(result = framing.getReducedResult(acc))) {\n        const r = await this.device.transferIn(endpointNumber, packetSize);\n        const buffer = Buffer.from(r.data.buffer);\n        acc = framing.reduceResponse(acc, buffer);\n      }\n\n      log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n      return result;\n    }).catch(e => {\n      if (e && e.message && e.message.includes(\"disconnected\")) {\n        this._emitDisconnect(e);\n\n        throw new DisconnectedDeviceDuringOperation(e.message);\n      }\n\n      throw e;\n    });\n\n    this.device = device;\n    this.interfaceNumber = interfaceNumber;\n    this.deviceModel = identifyUSBProductId(device.productId);\n  }\n  /**\n   * Check if WebUSB transport is supported.\n   */\n\n  /**\n   * Similar to create() except it will always display the device permission (even if some devices are already accepted).\n   */\n\n\n  static async request() {\n    const device = await requestLedgerDevice();\n    return TransportWebUSB.open(device);\n  }\n  /**\n   * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).\n   */\n\n\n  static async openConnected() {\n    const devices = await getLedgerDevices();\n    if (devices.length === 0) return null;\n    return TransportWebUSB.open(devices[0]);\n  }\n  /**\n   * Create a Ledger transport with a USBDevice\n   */\n\n\n  static async open(device) {\n    await device.open();\n\n    if (device.configuration === null) {\n      await device.selectConfiguration(configurationValue);\n    }\n\n    await gracefullyResetDevice(device);\n    const iface = device.configurations[0].interfaces.find(_ref => {\n      let {\n        alternates\n      } = _ref;\n      return alternates.some(a => a.interfaceClass === 255);\n    });\n\n    if (!iface) {\n      throw new TransportInterfaceNotAvailable(\"No WebUSB interface found for your Ledger device. Please upgrade firmware or contact techsupport.\");\n    }\n\n    const interfaceNumber = iface.interfaceNumber;\n\n    try {\n      await device.claimInterface(interfaceNumber);\n    } catch (e) {\n      await device.close();\n      throw new TransportInterfaceNotAvailable(e.message);\n    }\n\n    const transport = new TransportWebUSB(device, interfaceNumber);\n\n    const onDisconnect = e => {\n      if (device === e.device) {\n        // $FlowFixMe\n        navigator.usb.removeEventListener(\"disconnect\", onDisconnect);\n\n        transport._emitDisconnect(new DisconnectedDevice());\n      }\n    }; // $FlowFixMe\n\n\n    navigator.usb.addEventListener(\"disconnect\", onDisconnect);\n    return transport;\n  }\n  /**\n   * Release the transport device\n   */\n\n\n  async close() {\n    await this.exchangeBusyPromise;\n    await this.device.releaseInterface(this.interfaceNumber);\n    await gracefullyResetDevice(this.device);\n    await this.device.close();\n  }\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n\n\n  setScrambleKey() {}\n\n}\nTransportWebUSB.isSupported = isSupported;\nTransportWebUSB.list = getLedgerDevices;\n\nTransportWebUSB.listen = observer => {\n  let unsubscribed = false;\n  getFirstLedgerDevice().then(device => {\n    if (!unsubscribed) {\n      const deviceModel = identifyUSBProductId(device.productId);\n      observer.next({\n        type: \"add\",\n        descriptor: device,\n        deviceModel\n      });\n      observer.complete();\n    }\n  }, error => {\n    if (window.DOMException && error instanceof window.DOMException && error.code === 18) {\n      observer.error(new TransportWebUSBGestureRequired(error.message));\n    } else {\n      observer.error(new TransportOpenUserCancelled(error.message));\n    }\n  });\n\n  function unsubscribe() {\n    unsubscribed = true;\n  }\n\n  return {\n    unsubscribe\n  };\n};\n\nasync function gracefullyResetDevice(device) {\n  try {\n    await device.reset();\n  } catch (err) {\n    console.warn(err);\n  }\n}","map":{"version":3,"mappings":"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","names":["Transport","hidFraming","identifyUSBProductId","log","TransportOpenUserCancelled","TransportInterfaceNotAvailable","TransportWebUSBGestureRequired","DisconnectedDeviceDuringOperation","DisconnectedDevice","getLedgerDevices","getFirstLedgerDevice","requestLedgerDevice","isSupported","configurationValue","endpointNumber","TransportWebUSB","constructor","device","interfaceNumber","deviceModel","channel","Math","floor","random","packetSize","_disconnectEmitted","_emitDisconnect","e","emit","exchange","apdu","exchangeAtomicImpl","toString","framing","blocks","makeBlocks","i","length","transferOut","result","acc","getReducedResult","r","transferIn","buffer","Buffer","from","data","reduceResponse","catch","message","includes","productId","request","open","openConnected","devices","configuration","selectConfiguration","gracefullyResetDevice","iface","configurations","interfaces","find","alternates","some","a","interfaceClass","claimInterface","close","transport","onDisconnect","navigator","usb","removeEventListener","addEventListener","exchangeBusyPromise","releaseInterface","setScrambleKey","list","listen","observer","unsubscribed","then","next","type","descriptor","complete","error","window","DOMException","code","unsubscribe","reset","err","console","warn"],"sources":["/home/rybakisa/Desktop/TEMP/HackaTON/TON Ads/ton-ads/node_modules/@ledgerhq/hw-transport-webusb/src/TransportWebUSB.js"],"sourcesContent":["//@flow\nimport Transport from \"@ledgerhq/hw-transport\";\nimport type {\n  Observer,\n  DescriptorEvent,\n  Subscription,\n} from \"@ledgerhq/hw-transport\";\nimport hidFraming from \"@ledgerhq/devices/lib/hid-framing\";\nimport { identifyUSBProductId } from \"@ledgerhq/devices\";\nimport type { DeviceModel } from \"@ledgerhq/devices\";\nimport { log } from \"@ledgerhq/logs\";\nimport {\n  TransportOpenUserCancelled,\n  TransportInterfaceNotAvailable,\n  TransportWebUSBGestureRequired,\n  DisconnectedDeviceDuringOperation,\n  DisconnectedDevice,\n} from \"@ledgerhq/errors\";\nimport {\n  getLedgerDevices,\n  getFirstLedgerDevice,\n  requestLedgerDevice,\n  isSupported,\n} from \"./webusb\";\n\nconst configurationValue = 1;\nconst endpointNumber = 3;\n\n/**\n * WebUSB Transport implementation\n * @example\n * import TransportWebUSB from \"@ledgerhq/hw-transport-webusb\";\n * ...\n * TransportWebUSB.create().then(transport => ...)\n */\nexport default class TransportWebUSB extends Transport<USBDevice> {\n  device: USBDevice;\n  deviceModel: ?DeviceModel;\n  channel = Math.floor(Math.random() * 0xffff);\n  packetSize = 64;\n  interfaceNumber: number;\n\n  constructor(device: USBDevice, interfaceNumber: number) {\n    super();\n    this.device = device;\n    this.interfaceNumber = interfaceNumber;\n    this.deviceModel = identifyUSBProductId(device.productId);\n  }\n\n  /**\n   * Check if WebUSB transport is supported.\n   */\n  static isSupported = isSupported;\n\n  /**\n   * List the WebUSB devices that was previously authorized by the user.\n   */\n  static list = getLedgerDevices;\n\n  /**\n   * Actively listen to WebUSB devices and emit ONE device\n   * that was either accepted before, if not it will trigger the native permission UI.\n   *\n   * Important: it must be called in the context of a UI click!\n   */\n  static listen = (\n    observer: Observer<DescriptorEvent<USBDevice>>\n  ): Subscription => {\n    let unsubscribed = false;\n    getFirstLedgerDevice().then(\n      (device) => {\n        if (!unsubscribed) {\n          const deviceModel = identifyUSBProductId(device.productId);\n          observer.next({ type: \"add\", descriptor: device, deviceModel });\n          observer.complete();\n        }\n      },\n      (error) => {\n        if (\n          window.DOMException &&\n          error instanceof window.DOMException &&\n          error.code === 18\n        ) {\n          observer.error(new TransportWebUSBGestureRequired(error.message));\n        } else {\n          observer.error(new TransportOpenUserCancelled(error.message));\n        }\n      }\n    );\n    function unsubscribe() {\n      unsubscribed = true;\n    }\n    return { unsubscribe };\n  };\n\n  /**\n   * Similar to create() except it will always display the device permission (even if some devices are already accepted).\n   */\n  static async request() {\n    const device = await requestLedgerDevice();\n    return TransportWebUSB.open(device);\n  }\n\n  /**\n   * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).\n   */\n  static async openConnected() {\n    const devices = await getLedgerDevices();\n    if (devices.length === 0) return null;\n    return TransportWebUSB.open(devices[0]);\n  }\n\n  /**\n   * Create a Ledger transport with a USBDevice\n   */\n  static async open(device: USBDevice) {\n    await device.open();\n    if (device.configuration === null) {\n      await device.selectConfiguration(configurationValue);\n    }\n    await gracefullyResetDevice(device);\n    const iface = device.configurations[0].interfaces.find(({ alternates }) =>\n      alternates.some((a) => a.interfaceClass === 255)\n    );\n    if (!iface) {\n      throw new TransportInterfaceNotAvailable(\n        \"No WebUSB interface found for your Ledger device. Please upgrade firmware or contact techsupport.\"\n      );\n    }\n    const interfaceNumber = iface.interfaceNumber;\n    try {\n      await device.claimInterface(interfaceNumber);\n    } catch (e) {\n      await device.close();\n      throw new TransportInterfaceNotAvailable(e.message);\n    }\n    const transport = new TransportWebUSB(device, interfaceNumber);\n    const onDisconnect = (e) => {\n      if (device === e.device) {\n        // $FlowFixMe\n        navigator.usb.removeEventListener(\"disconnect\", onDisconnect);\n        transport._emitDisconnect(new DisconnectedDevice());\n      }\n    };\n    // $FlowFixMe\n    navigator.usb.addEventListener(\"disconnect\", onDisconnect);\n    return transport;\n  }\n\n  _disconnectEmitted = false;\n  _emitDisconnect = (e: Error) => {\n    if (this._disconnectEmitted) return;\n    this._disconnectEmitted = true;\n    this.emit(\"disconnect\", e);\n  };\n\n  /**\n   * Release the transport device\n   */\n  async close(): Promise<void> {\n    await this.exchangeBusyPromise;\n    await this.device.releaseInterface(this.interfaceNumber);\n    await gracefullyResetDevice(this.device);\n    await this.device.close();\n  }\n\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n  exchange = (apdu: Buffer): Promise<Buffer> =>\n    this.exchangeAtomicImpl(async () => {\n      const { channel, packetSize } = this;\n      log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n\n      const framing = hidFraming(channel, packetSize);\n\n      // Write...\n      const blocks = framing.makeBlocks(apdu);\n      for (let i = 0; i < blocks.length; i++) {\n        await this.device.transferOut(endpointNumber, blocks[i]);\n      }\n\n      // Read...\n      let result;\n      let acc;\n      while (!(result = framing.getReducedResult(acc))) {\n        const r = await this.device.transferIn(endpointNumber, packetSize);\n        const buffer = Buffer.from(r.data.buffer);\n        acc = framing.reduceResponse(acc, buffer);\n      }\n\n      log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n      return result;\n    }).catch((e) => {\n      if (e && e.message && e.message.includes(\"disconnected\")) {\n        this._emitDisconnect(e);\n        throw new DisconnectedDeviceDuringOperation(e.message);\n      }\n      throw e;\n    });\n\n  setScrambleKey() {}\n}\n\nasync function gracefullyResetDevice(device: USBDevice) {\n  try {\n    await device.reset();\n  } catch (err) {\n    console.warn(err);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}