{"ast":null,"code":"const {\n  base64ToBytes,\n  Address\n} = require(\"../../../utils\");\n\nconst {\n  Cell\n} = require(\"../../../boc\");\n\nconst SNAKE_DATA_PREFIX = 0x00;\nconst CHUNK_DATA_PREFIX = 0x01;\nconst ONCHAIN_CONTENT_PREFIX = 0x00;\nconst OFFCHAIN_CONTENT_PREFIX = 0x01;\n/**\n * @param uri   {string}\n * @returns {Uint8Array}\n */\n\nconst serializeUri = uri => {\n  return new TextEncoder().encode(encodeURI(uri));\n};\n/**\n * @param bytes {Uint8Array}\n * @return {string}\n */\n\n\nconst parseUri = bytes => {\n  return new TextDecoder().decode(bytes);\n};\n/**\n * @param uri {string}\n * @return {Cell}\n */\n\n\nconst createOffchainUriCell = uri => {\n  const cell = new Cell();\n  cell.bits.writeUint(OFFCHAIN_CONTENT_PREFIX, 8);\n  cell.bits.writeBytes(serializeUri(uri));\n  return cell;\n};\n/**\n * @param cell {Cell}\n * @returns {string}\n */\n\n\nconst parseOffchainUriCell = cell => {\n  let length = 0;\n  let c = cell;\n\n  while (c) {\n    length += c.bits.array.length;\n    c = c.refs[0];\n  }\n\n  const bytes = new Uint8Array(length);\n  length = 0;\n  c = cell;\n\n  while (c) {\n    bytes.set(c.bits.array, length);\n    length += c.bits.array.length;\n    c = c.refs[0];\n  }\n\n  return parseUri(bytes.slice(1)); // slice OFFCHAIN_CONTENT_PREFIX\n};\n/**\n * @param bs    {BitString}\n * @param cursor    {number}\n * @param bits  {number}\n * @return {BigInt}\n */\n\n\nconst readIntFromBitString = (bs, cursor, bits) => {\n  let n = BigInt(0);\n\n  for (let i = 0; i < bits; i++) {\n    n *= BigInt(2);\n    n += BigInt(bs.get(cursor + i));\n  }\n\n  return n;\n};\n/**\n * @param cell  {Cell}\n * @return {Address|null}\n */\n\n\nconst parseAddress = cell => {\n  let n = readIntFromBitString(cell.bits, 3, 8);\n\n  if (n > BigInt(127)) {\n    n = n - BigInt(256);\n  }\n\n  const hashPart = readIntFromBitString(cell.bits, 3 + 8, 256);\n  if (n.toString(10) + \":\" + hashPart.toString(16) === '0:0') return null;\n  const s = n.toString(10) + \":\" + hashPart.toString(16).padStart(64, '0');\n  return new Address(s);\n};\n/**\n * @param provider {HttpProvider}\n * @param address {string}\n * @return {Promise<{royalty: number, royaltyFactor: number, royaltyBase: number, royaltyAddress: Address}>}\n */\n\n\nconst getRoyaltyParams = async (provider, address) => {\n  const result = await provider.call2(address, 'royalty_params');\n  const royaltyFactor = result[0].toNumber();\n  const royaltyBase = result[1].toNumber();\n  const royalty = royaltyFactor / royaltyBase;\n  const royaltyAddress = parseAddress(result[2]);\n  return {\n    royalty,\n    royaltyBase,\n    royaltyFactor,\n    royaltyAddress\n  };\n};\n\nmodule.exports = {\n  SNAKE_DATA_PREFIX,\n  CHUNK_DATA_PREFIX,\n  ONCHAIN_CONTENT_PREFIX,\n  OFFCHAIN_CONTENT_PREFIX,\n  parseAddress,\n  serializeUri,\n  parseUri,\n  createOffchainUriCell,\n  parseOffchainUriCell,\n  getRoyaltyParams\n};","map":{"version":3,"names":["base64ToBytes","Address","require","Cell","SNAKE_DATA_PREFIX","CHUNK_DATA_PREFIX","ONCHAIN_CONTENT_PREFIX","OFFCHAIN_CONTENT_PREFIX","serializeUri","uri","TextEncoder","encode","encodeURI","parseUri","bytes","TextDecoder","decode","createOffchainUriCell","cell","bits","writeUint","writeBytes","parseOffchainUriCell","length","c","array","refs","Uint8Array","set","slice","readIntFromBitString","bs","cursor","n","BigInt","i","get","parseAddress","hashPart","toString","s","padStart","getRoyaltyParams","provider","address","result","call2","royaltyFactor","toNumber","royaltyBase","royalty","royaltyAddress","module","exports"],"sources":["/home/rybakisa/Desktop/TEMP/HackaTON/TON Ads/ton-ads/node_modules/tonweb/src/contract/token/nft/NftUtils.js"],"sourcesContent":["const {base64ToBytes, Address} = require(\"../../../utils\");\nconst {Cell} = require(\"../../../boc\");\n\nconst SNAKE_DATA_PREFIX = 0x00;\nconst CHUNK_DATA_PREFIX = 0x01;\nconst ONCHAIN_CONTENT_PREFIX = 0x00;\nconst OFFCHAIN_CONTENT_PREFIX = 0x01;\n\n/**\n * @param uri   {string}\n * @returns {Uint8Array}\n */\nconst serializeUri = (uri) => {\n    return new TextEncoder().encode(encodeURI(uri));\n}\n\n/**\n * @param bytes {Uint8Array}\n * @return {string}\n */\nconst parseUri = (bytes) => {\n    return new TextDecoder().decode(bytes);\n}\n\n/**\n * @param uri {string}\n * @return {Cell}\n */\nconst createOffchainUriCell = (uri) => {\n    const cell = new Cell();\n    cell.bits.writeUint(OFFCHAIN_CONTENT_PREFIX, 8);\n    cell.bits.writeBytes(serializeUri(uri));\n    return cell;\n}\n\n/**\n * @param cell {Cell}\n * @returns {string}\n */\nconst parseOffchainUriCell = (cell) => {\n    let length = 0;\n    let c = cell;\n    while (c) {\n        length += c.bits.array.length;\n        c = c.refs[0];\n    }\n\n    const bytes = new Uint8Array(length);\n    length = 0;\n    c = cell;\n    while (c) {\n        bytes.set(c.bits.array, length)\n        length += c.bits.array.length;\n        c = c.refs[0];\n    }\n    return parseUri(bytes.slice(1)); // slice OFFCHAIN_CONTENT_PREFIX\n}\n\n/**\n * @param bs    {BitString}\n * @param cursor    {number}\n * @param bits  {number}\n * @return {BigInt}\n */\nconst readIntFromBitString = (bs, cursor, bits) => {\n    let n = BigInt(0);\n    for (let i = 0; i < bits; i++) {\n        n *= BigInt(2);\n        n += BigInt(bs.get(cursor + i));\n    }\n    return n;\n}\n\n/**\n * @param cell  {Cell}\n * @return {Address|null}\n */\nconst parseAddress = cell => {\n    let n = readIntFromBitString(cell.bits, 3, 8);\n    if (n > BigInt(127)) {\n        n = n - BigInt(256);\n    }\n    const hashPart = readIntFromBitString(cell.bits, 3 + 8, 256);\n    if (n.toString(10) + \":\" + hashPart.toString(16) === '0:0') return null;\n    const s = n.toString(10) + \":\" + hashPart.toString(16).padStart(64, '0');\n    return new Address(s);\n};\n\n/**\n * @param provider {HttpProvider}\n * @param address {string}\n * @return {Promise<{royalty: number, royaltyFactor: number, royaltyBase: number, royaltyAddress: Address}>}\n */\nconst getRoyaltyParams = async (provider, address) => {\n    const result = await provider.call2(address, 'royalty_params');\n\n    const royaltyFactor = result[0].toNumber();\n    const royaltyBase = result[1].toNumber();\n    const royalty = royaltyFactor / royaltyBase;\n    const royaltyAddress = parseAddress(result[2]);\n\n    return {royalty, royaltyBase, royaltyFactor, royaltyAddress};\n}\n\nmodule.exports = {\n    SNAKE_DATA_PREFIX,\n    CHUNK_DATA_PREFIX,\n    ONCHAIN_CONTENT_PREFIX,\n    OFFCHAIN_CONTENT_PREFIX,\n    parseAddress,\n    serializeUri,\n    parseUri,\n    createOffchainUriCell,\n    parseOffchainUriCell,\n    getRoyaltyParams\n};"],"mappings":"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"},"metadata":{},"sourceType":"script"}