{"ast":null,"code":"import Transport from \"@ledgerhq/hw-transport\";\nimport hidFraming from \"@ledgerhq/devices/lib/hid-framing\";\nimport { identifyUSBProductId, ledgerUSBVendorId } from \"@ledgerhq/devices\";\nimport { log } from \"@ledgerhq/logs\";\nimport { TransportOpenUserCancelled, DisconnectedDeviceDuringOperation, DisconnectedDevice, TransportError } from \"@ledgerhq/errors\";\nconst ledgerDevices = [{\n  vendorId: ledgerUSBVendorId\n}];\n\nconst isSupported = () => Promise.resolve(!!(global.navigator && global.navigator.hid));\n\nconst getHID = () => {\n  // $FlowFixMe\n  const {\n    hid\n  } = navigator;\n  if (!hid) throw new TransportError(\"navigator.hid is not supported\", \"HIDNotSupported\");\n  return hid;\n};\n\nasync function requestLedgerDevices() {\n  const device = await getHID().requestDevice({\n    filters: ledgerDevices\n  });\n  if (Array.isArray(device)) return device;\n  return [device];\n}\n\nasync function getLedgerDevices() {\n  const devices = await getHID().getDevices();\n  return devices.filter(d => d.vendorId === ledgerUSBVendorId);\n}\n\nasync function getFirstLedgerDevice() {\n  const existingDevices = await getLedgerDevices();\n  if (existingDevices.length > 0) return existingDevices[0];\n  const devices = await requestLedgerDevices();\n  return devices[0];\n}\n/**\n * WebHID Transport implementation\n * @example\n * import TransportWebHID from \"@ledgerhq/hw-transport-webhid\";\n * ...\n * TransportWebHID.create().then(transport => ...)\n */\n\n\nexport default class TransportWebHID extends Transport {\n  constructor(device) {\n    super();\n    this.device = void 0;\n    this.deviceModel = void 0;\n    this.channel = Math.floor(Math.random() * 0xffff);\n    this.packetSize = 64;\n    this.inputs = [];\n    this.inputCallback = void 0;\n\n    this.read = () => {\n      if (this.inputs.length) {\n        return Promise.resolve(this.inputs.shift());\n      }\n\n      return new Promise(success => {\n        this.inputCallback = success;\n      });\n    };\n\n    this.onInputReport = e => {\n      const buffer = Buffer.from(e.data.buffer);\n\n      if (this.inputCallback) {\n        this.inputCallback(buffer);\n        this.inputCallback = null;\n      } else {\n        this.inputs.push(buffer);\n      }\n    };\n\n    this._disconnectEmitted = false;\n\n    this._emitDisconnect = e => {\n      if (this._disconnectEmitted) return;\n      this._disconnectEmitted = true;\n      this.emit(\"disconnect\", e);\n    };\n\n    this.exchange = apdu => this.exchangeAtomicImpl(async () => {\n      const {\n        channel,\n        packetSize\n      } = this;\n      log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n      const framing = hidFraming(channel, packetSize); // Write...\n\n      const blocks = framing.makeBlocks(apdu);\n\n      for (let i = 0; i < blocks.length; i++) {\n        await this.device.sendReport(0, blocks[i]);\n      } // Read...\n\n\n      let result;\n      let acc;\n\n      while (!(result = framing.getReducedResult(acc))) {\n        const buffer = await this.read();\n        acc = framing.reduceResponse(acc, buffer);\n      }\n\n      log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n      return result;\n    }).catch(e => {\n      if (e && e.message && e.message.includes(\"write\")) {\n        this._emitDisconnect(e);\n\n        throw new DisconnectedDeviceDuringOperation(e.message);\n      }\n\n      throw e;\n    });\n\n    this.device = device;\n    this.deviceModel = identifyUSBProductId(device.productId);\n    device.addEventListener(\"inputreport\", this.onInputReport);\n  }\n  /**\n   * Similar to create() except it will always display the device permission (even if some devices are already accepted).\n   */\n\n\n  static async request() {\n    const [device] = await requestLedgerDevices();\n    return TransportWebHID.open(device);\n  }\n  /**\n   * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).\n   */\n\n\n  static async openConnected() {\n    const devices = await getLedgerDevices();\n    if (devices.length === 0) return null;\n    return TransportWebHID.open(devices[0]);\n  }\n  /**\n   * Create a Ledger transport with a HIDDevice\n   */\n\n\n  static async open(device) {\n    await device.open();\n    const transport = new TransportWebHID(device);\n\n    const onDisconnect = e => {\n      if (device === e.device) {\n        getHID().removeEventListener(\"disconnect\", onDisconnect);\n\n        transport._emitDisconnect(new DisconnectedDevice());\n      }\n    };\n\n    getHID().addEventListener(\"disconnect\", onDisconnect);\n    return transport;\n  }\n  /**\n   * Release the transport device\n   */\n\n\n  async close() {\n    await this.exchangeBusyPromise;\n    this.device.removeEventListener(\"inputreport\", this.onInputReport);\n    await this.device.close();\n  }\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n\n\n  setScrambleKey() {}\n\n}\nTransportWebHID.isSupported = isSupported;\nTransportWebHID.list = getLedgerDevices;\n\nTransportWebHID.listen = observer => {\n  let unsubscribed = false;\n  getFirstLedgerDevice().then(device => {\n    if (!device) {\n      observer.error(new TransportOpenUserCancelled(\"Access denied to use Ledger device\"));\n    } else if (!unsubscribed) {\n      const deviceModel = identifyUSBProductId(device.productId);\n      observer.next({\n        type: \"add\",\n        descriptor: device,\n        deviceModel\n      });\n      observer.complete();\n    }\n  }, error => {\n    observer.error(new TransportOpenUserCancelled(error.message));\n  });\n\n  function unsubscribe() {\n    unsubscribed = true;\n  }\n\n  return {\n    unsubscribe\n  };\n};","map":{"version":3,"mappings":"AACA,OAAOA,SAAP,MAAsB,wBAAtB;AAMA,OAAOC,UAAP,MAAuB,mCAAvB;AACA,SAASC,oBAAT,EAA+BC,iBAA/B,QAAwD,mBAAxD;AAEA,SAASC,GAAT,QAAoB,gBAApB;AACA,SACEC,0BADF,EAEEC,iCAFF,EAGEC,kBAHF,EAIEC,cAJF,QAKO,kBALP;AAOA,MAAMC,aAAa,GAAG,CAAC;EAAEC,QAAQ,EAAEP;AAAZ,CAAD,CAAtB;;AAEA,MAAMQ,WAAW,GAAG,MAClBC,OAAO,CAACC,OAARD,CAAgB,CAAC,EAAEE,MAAM,CAACC,SAAPD,IAAoBA,MAAM,CAACC,SAAPD,CAAiBE,GAAvC,CAAjBJ,CADF;;AAGA,MAAMK,MAAM,GAAG,MAAW;EACxB;EACA,MAAM;IAAED;EAAF,IAAUD,SAAhB;EACA,IAAI,CAACC,GAAL,EACE,MAAM,IAAIR,cAAJ,CACJ,gCADI,EAEJ,iBAFI,CAAN;EAIF,OAAOQ,GAAP;AARF;;AAWA,eAAeE,oBAAf,GAA4D;EAC1D,MAAMC,MAAM,GAAG,MAAMF,MAAM,GAAGG,aAATH,CAAuB;IAAEI,OAAO,EAAEZ;EAAX,CAAvBQ,CAArB;EACA,IAAIK,KAAK,CAACC,OAAND,CAAcH,MAAdG,CAAJ,EAA2B,OAAOH,MAAP;EAC3B,OAAO,CAACA,MAAD,CAAP;AACD;;AAED,eAAeK,gBAAf,GAAwD;EACtD,MAAMC,OAAO,GAAG,MAAMR,MAAM,GAAGS,UAATT,EAAtB;EACA,OAAOQ,OAAO,CAACE,MAARF,CAAgBG,CAAD,IAAOA,CAAC,CAAClB,QAAFkB,KAAezB,iBAArCsB,CAAP;AACD;;AAED,eAAeI,oBAAf,GAA0D;EACxD,MAAMC,eAAe,GAAG,MAAMN,gBAAgB,EAA9C;EACA,IAAIM,eAAe,CAACC,MAAhBD,GAAyB,CAA7B,EAAgC,OAAOA,eAAe,CAAC,CAAD,CAAtB;EAChC,MAAML,OAAO,GAAG,MAAMP,oBAAoB,EAA1C;EACA,OAAOO,OAAO,CAAC,CAAD,CAAd;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,eAAe,MAAMO,eAAN,SAA8BhC,SAA9B,CAAmD;EAMhEiC,WAAW,CAACd,MAAD,EAAoB;IAC7B;IAD6B,KAL/BA,MAK+B;IAAA,KAJ/Be,WAI+B;IAAA,KAH/BC,OAG+B,GAHrBC,IAAI,CAACC,KAALD,CAAWA,IAAI,CAACE,MAALF,KAAgB,MAA3BA,CAGqB;IAAA,KAF/BG,UAE+B,GAFlB,EAEkB;IAAA,KAO/BC,MAP+B,GAOtB,EAPsB;IAAA,KAQ/BC,aAR+B;;IAAA,KAU/BC,IAV+B,GAUxB,MAAuB;MAC5B,IAAI,KAAKF,MAAL,CAAYT,MAAhB,EAAwB;QACtB,OAAOnB,OAAO,CAACC,OAARD,CAAgB,KAAK4B,MAAL,CAAYG,KAAZ,EAAhB/B,CAAP;MACD;;MACD,OAAO,IAAIA,OAAJ,CAAagC,OAAD,IAAa;QAC9B,KAAKH,aAAL,GAAqBG,OAArB;MADK,EAAP;IAd6B;;IAAA,KAmB/BC,aAnB+B,GAmBdC,CAAD,IAAyB;MACvC,MAAMC,MAAM,GAAGC,MAAM,CAACC,IAAPD,CAAYF,CAAC,CAACI,IAAFJ,CAAOC,MAAnBC,CAAf;;MACA,IAAI,KAAKP,aAAT,EAAwB;QACtB,KAAKA,aAAL,CAAmBM,MAAnB;QACA,KAAKN,aAAL,GAAqB,IAArB;MAFF,OAGO;QACL,KAAKD,MAAL,CAAYW,IAAZ,CAAiBJ,MAAjB;MACD;IA1B4B;;IAAA,KAwG/BK,kBAxG+B,GAwGV,KAxGU;;IAAA,KAyG/BC,eAzG+B,GAyGZP,CAAD,IAAc;MAC9B,IAAI,KAAKM,kBAAT,EAA6B;MAC7B,KAAKA,kBAAL,GAA0B,IAA1B;MACA,KAAKE,IAAL,CAAU,YAAV,EAAwBR,CAAxB;IA5G6B;;IAAA,KA6H/BS,QA7H+B,GA6HnBC,IAAD,IACT,KAAKC,kBAAL,CAAwB,YAAY;MAClC,MAAM;QAAEtB,OAAF;QAAWI;MAAX,IAA0B,IAAhC;MACAnC,GAAG,CAAC,MAAD,EAAS,QAAQoD,IAAI,CAACE,QAALF,CAAc,KAAdA,CAAjB,CAAHpD;MAEA,MAAMuD,OAAO,GAAG1D,UAAU,CAACkC,OAAD,EAAUI,UAAV,CAA1B,CAJkC,CAMlC;;MACA,MAAMqB,MAAM,GAAGD,OAAO,CAACE,UAARF,CAAmBH,IAAnBG,CAAf;;MACA,KAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,MAAM,CAAC7B,MAA3B,EAAmC+B,CAAC,EAApC,EAAwC;QACtC,MAAM,KAAK3C,MAAL,CAAY4C,UAAZ,CAAuB,CAAvB,EAA0BH,MAAM,CAACE,CAAD,CAAhC,CAAN;MATgC,EAYlC;;;MACA,IAAIE,MAAJ;MACA,IAAIC,GAAJ;;MACA,OAAO,EAAED,MAAM,GAAGL,OAAO,CAACO,gBAARP,CAAyBM,GAAzBN,CAAX,CAAP,EAAkD;QAChD,MAAMZ,MAAM,GAAG,MAAM,KAAKL,IAAL,EAArB;QACAuB,GAAG,GAAGN,OAAO,CAACQ,cAARR,CAAuBM,GAAvBN,EAA4BZ,MAA5BY,CAANM;MACD;;MAED7D,GAAG,CAAC,MAAD,EAAS,QAAQ4D,MAAM,CAACN,QAAPM,CAAgB,KAAhBA,CAAjB,CAAH5D;MACA,OAAO4D,MAAP;IArBF,GAsBGI,KAtBH,CAsBUtB,CAAD,IAAO;MACd,IAAIA,CAAC,IAAIA,CAAC,CAACuB,OAAPvB,IAAkBA,CAAC,CAACuB,OAAFvB,CAAUwB,QAAVxB,CAAmB,OAAnBA,CAAtB,EAAmD;QACjD,KAAKO,eAAL,CAAqBP,CAArB;;QACA,MAAM,IAAIxC,iCAAJ,CAAsCwC,CAAC,CAACuB,OAAxC,CAAN;MACD;;MACD,MAAMvB,CAAN;IA3BF,EA9H6B;;IAE7B,KAAK3B,MAAL,GAAcA,MAAd;IACA,KAAKe,WAAL,GAAmBhC,oBAAoB,CAACiB,MAAM,CAACoD,SAAR,CAAvC;IACApD,MAAM,CAACqD,gBAAPrD,CAAwB,aAAxBA,EAAuC,KAAK0B,aAA5C1B;EACD;EAkED;AACF;AACA;;;EACE,aAAasD,OAAb,GAAuB;IACrB,MAAM,CAACtD,MAAD,IAAW,MAAMD,oBAAoB,EAA3C;IACA,OAAOc,eAAe,CAAC0C,IAAhB1C,CAAqBb,MAArBa,CAAP;EACD;EAED;AACF;AACA;;;EACE,aAAa2C,aAAb,GAA6B;IAC3B,MAAMlD,OAAO,GAAG,MAAMD,gBAAgB,EAAtC;IACA,IAAIC,OAAO,CAACM,MAARN,KAAmB,CAAvB,EAA0B,OAAO,IAAP;IAC1B,OAAOO,eAAe,CAAC0C,IAAhB1C,CAAqBP,OAAO,CAAC,CAAD,CAA5BO,CAAP;EACD;EAED;AACF;AACA;;;EACE,aAAa0C,IAAb,CAAkBvD,MAAlB,EAAqC;IACnC,MAAMA,MAAM,CAACuD,IAAPvD,EAAN;IACA,MAAMyD,SAAS,GAAG,IAAI5C,eAAJ,CAAoBb,MAApB,CAAlB;;IACA,MAAM0D,YAAY,GAAI/B,CAAD,IAAO;MAC1B,IAAI3B,MAAM,KAAK2B,CAAC,CAAC3B,MAAjB,EAAyB;QACvBF,MAAM,GAAG6D,mBAAT7D,CAA6B,YAA7BA,EAA2C4D,YAA3C5D;;QACA2D,SAAS,CAACvB,eAAVuB,CAA0B,IAAIrE,kBAAJ,EAA1BqE;MACD;IAJH;;IAMA3D,MAAM,GAAGuD,gBAATvD,CAA0B,YAA1BA,EAAwC4D,YAAxC5D;IACA,OAAO2D,SAAP;EACD;EASD;AACF;AACA;;;EACE,MAAMG,KAAN,GAA6B;IAC3B,MAAM,KAAKC,mBAAX;IACA,KAAK7D,MAAL,CAAY2D,mBAAZ,CAAgC,aAAhC,EAA+C,KAAKjC,aAApD;IACA,MAAM,KAAK1B,MAAL,CAAY4D,KAAZ,EAAN;EACD;EAED;AACF;AACA;AACA;AACA;;;EAgCEE,cAAc,GAAG,CAAE;;AAlK6C;AAA7CjD,e,CAsCZrB,WAtCYqB,GAsCErB,WAtCFqB;AAAAA,e,CA2CZkD,IA3CYlD,GA2CLR,gBA3CKQ;;AAAAA,e,CAmDZmD,MAnDYnD,GAoDjBoD,QADc,IAEG;EACjB,IAAIC,YAAY,GAAG,KAAnB;EACAxD,oBAAoB,GAAGyD,IAAvBzD,CACGV,MAAD,IAAY;IACV,IAAI,CAACA,MAAL,EAAa;MACXiE,QAAQ,CAACG,KAATH,CACE,IAAI/E,0BAAJ,CAA+B,oCAA/B,CADF+E;IADF,OAIO,IAAI,CAACC,YAAL,EAAmB;MACxB,MAAMnD,WAAW,GAAGhC,oBAAoB,CAACiB,MAAM,CAACoD,SAAR,CAAxC;MACAa,QAAQ,CAACI,IAATJ,CAAc;QAAEK,IAAI,EAAE,KAAR;QAAeC,UAAU,EAAEvE,MAA3B;QAAmCe;MAAnC,CAAdkD;MACAA,QAAQ,CAACO,QAATP;IACD;EAVL,GAYGG,KAAD,IAAW;IACTH,QAAQ,CAACG,KAATH,CAAe,IAAI/E,0BAAJ,CAA+BkF,KAAK,CAAClB,OAArC,CAAfe;EAbJ;;EAgBA,SAASQ,WAAT,GAAuB;IACrBP,YAAY,GAAG,IAAfA;EACD;;EACD,OAAO;IAAEO;EAAF,CAAP;CA1EiB5D","names":["Transport","hidFraming","identifyUSBProductId","ledgerUSBVendorId","log","TransportOpenUserCancelled","DisconnectedDeviceDuringOperation","DisconnectedDevice","TransportError","ledgerDevices","vendorId","isSupported","Promise","resolve","global","navigator","hid","getHID","requestLedgerDevices","device","requestDevice","filters","Array","isArray","getLedgerDevices","devices","getDevices","filter","d","getFirstLedgerDevice","existingDevices","length","TransportWebHID","constructor","deviceModel","channel","Math","floor","random","packetSize","inputs","inputCallback","read","shift","success","onInputReport","e","buffer","Buffer","from","data","push","_disconnectEmitted","_emitDisconnect","emit","exchange","apdu","exchangeAtomicImpl","toString","framing","blocks","makeBlocks","i","sendReport","result","acc","getReducedResult","reduceResponse","catch","message","includes","productId","addEventListener","request","open","openConnected","transport","onDisconnect","removeEventListener","close","exchangeBusyPromise","setScrambleKey","list","listen","observer","unsubscribed","then","error","next","type","descriptor","complete","unsubscribe"],"sources":["/home/rybakisa/Desktop/TEMP/HackaTON/TON Ads/ton-ads/node_modules/@ledgerhq/hw-transport-webhid/src/TransportWebHID.js"],"sourcesContent":["//@flow\nimport Transport from \"@ledgerhq/hw-transport\";\nimport type {\n  Observer,\n  DescriptorEvent,\n  Subscription,\n} from \"@ledgerhq/hw-transport\";\nimport hidFraming from \"@ledgerhq/devices/lib/hid-framing\";\nimport { identifyUSBProductId, ledgerUSBVendorId } from \"@ledgerhq/devices\";\nimport type { DeviceModel } from \"@ledgerhq/devices\";\nimport { log } from \"@ledgerhq/logs\";\nimport {\n  TransportOpenUserCancelled,\n  DisconnectedDeviceDuringOperation,\n  DisconnectedDevice,\n  TransportError,\n} from \"@ledgerhq/errors\";\n\nconst ledgerDevices = [{ vendorId: ledgerUSBVendorId }];\n\nconst isSupported = () =>\n  Promise.resolve(!!(global.navigator && global.navigator.hid));\n\nconst getHID = (): HID => {\n  // $FlowFixMe\n  const { hid } = navigator;\n  if (!hid)\n    throw new TransportError(\n      \"navigator.hid is not supported\",\n      \"HIDNotSupported\"\n    );\n  return hid;\n};\n\nasync function requestLedgerDevices(): Promise<HIDDevice[]> {\n  const device = await getHID().requestDevice({ filters: ledgerDevices });\n  if (Array.isArray(device)) return device;\n  return [device];\n}\n\nasync function getLedgerDevices(): Promise<HIDDevice[]> {\n  const devices = await getHID().getDevices();\n  return devices.filter((d) => d.vendorId === ledgerUSBVendorId);\n}\n\nasync function getFirstLedgerDevice(): Promise<HIDDevice> {\n  const existingDevices = await getLedgerDevices();\n  if (existingDevices.length > 0) return existingDevices[0];\n  const devices = await requestLedgerDevices();\n  return devices[0];\n}\n\n/**\n * WebHID Transport implementation\n * @example\n * import TransportWebHID from \"@ledgerhq/hw-transport-webhid\";\n * ...\n * TransportWebHID.create().then(transport => ...)\n */\nexport default class TransportWebHID extends Transport<HIDDevice> {\n  device: HIDDevice;\n  deviceModel: ?DeviceModel;\n  channel = Math.floor(Math.random() * 0xffff);\n  packetSize = 64;\n\n  constructor(device: HIDDevice) {\n    super();\n    this.device = device;\n    this.deviceModel = identifyUSBProductId(device.productId);\n    device.addEventListener(\"inputreport\", this.onInputReport);\n  }\n\n  inputs = [];\n  inputCallback: ?(Buffer) => void;\n\n  read = (): Promise<Buffer> => {\n    if (this.inputs.length) {\n      return Promise.resolve(this.inputs.shift());\n    }\n    return new Promise((success) => {\n      this.inputCallback = success;\n    });\n  };\n\n  onInputReport = (e: InputReportEvent) => {\n    const buffer = Buffer.from(e.data.buffer);\n    if (this.inputCallback) {\n      this.inputCallback(buffer);\n      this.inputCallback = null;\n    } else {\n      this.inputs.push(buffer);\n    }\n  };\n\n  /**\n   * Check if WebUSB transport is supported.\n   */\n  static isSupported = isSupported;\n\n  /**\n   * List the WebUSB devices that was previously authorized by the user.\n   */\n  static list = getLedgerDevices;\n\n  /**\n   * Actively listen to WebUSB devices and emit ONE device\n   * that was either accepted before, if not it will trigger the native permission UI.\n   *\n   * Important: it must be called in the context of a UI click!\n   */\n  static listen = (\n    observer: Observer<DescriptorEvent<HIDDevice>>\n  ): Subscription => {\n    let unsubscribed = false;\n    getFirstLedgerDevice().then(\n      (device) => {\n        if (!device) {\n          observer.error(\n            new TransportOpenUserCancelled(\"Access denied to use Ledger device\")\n          );\n        } else if (!unsubscribed) {\n          const deviceModel = identifyUSBProductId(device.productId);\n          observer.next({ type: \"add\", descriptor: device, deviceModel });\n          observer.complete();\n        }\n      },\n      (error) => {\n        observer.error(new TransportOpenUserCancelled(error.message));\n      }\n    );\n    function unsubscribe() {\n      unsubscribed = true;\n    }\n    return { unsubscribe };\n  };\n\n  /**\n   * Similar to create() except it will always display the device permission (even if some devices are already accepted).\n   */\n  static async request() {\n    const [device] = await requestLedgerDevices();\n    return TransportWebHID.open(device);\n  }\n\n  /**\n   * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).\n   */\n  static async openConnected() {\n    const devices = await getLedgerDevices();\n    if (devices.length === 0) return null;\n    return TransportWebHID.open(devices[0]);\n  }\n\n  /**\n   * Create a Ledger transport with a HIDDevice\n   */\n  static async open(device: HIDDevice) {\n    await device.open();\n    const transport = new TransportWebHID(device);\n    const onDisconnect = (e) => {\n      if (device === e.device) {\n        getHID().removeEventListener(\"disconnect\", onDisconnect);\n        transport._emitDisconnect(new DisconnectedDevice());\n      }\n    };\n    getHID().addEventListener(\"disconnect\", onDisconnect);\n    return transport;\n  }\n\n  _disconnectEmitted = false;\n  _emitDisconnect = (e: Error) => {\n    if (this._disconnectEmitted) return;\n    this._disconnectEmitted = true;\n    this.emit(\"disconnect\", e);\n  };\n\n  /**\n   * Release the transport device\n   */\n  async close(): Promise<void> {\n    await this.exchangeBusyPromise;\n    this.device.removeEventListener(\"inputreport\", this.onInputReport);\n    await this.device.close();\n  }\n\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n  exchange = (apdu: Buffer): Promise<Buffer> =>\n    this.exchangeAtomicImpl(async () => {\n      const { channel, packetSize } = this;\n      log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n\n      const framing = hidFraming(channel, packetSize);\n\n      // Write...\n      const blocks = framing.makeBlocks(apdu);\n      for (let i = 0; i < blocks.length; i++) {\n        await this.device.sendReport(0, blocks[i]);\n      }\n\n      // Read...\n      let result;\n      let acc;\n      while (!(result = framing.getReducedResult(acc))) {\n        const buffer = await this.read();\n        acc = framing.reduceResponse(acc, buffer);\n      }\n\n      log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n      return result;\n    }).catch((e) => {\n      if (e && e.message && e.message.includes(\"write\")) {\n        this._emitDisconnect(e);\n        throw new DisconnectedDeviceDuringOperation(e.message);\n      }\n      throw e;\n    });\n\n  setScrambleKey() {}\n}\n"]},"metadata":{},"sourceType":"module"}