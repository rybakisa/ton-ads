{"ast":null,"code":"// NOTE: \"mc\" means masterchain, \"shards\" means shardchains\nconst MC_INTERVAL = 10 * 1000;\nconst SHARDS_INTERVAL = 1 * 1000;\n\nconst parseShardBlockNumber = x => {\n  return {\n    workchain: x.workchain,\n    shardId: x.shard,\n    shardBlockNumber: x.seqno\n  };\n};\n\nclass BlockSubscription {\n  /**\n   * @param provider  {TonWeb.HttpProvider}\n   * @param storage   persistent storage for storing block numbers that we have already processed.\n   * @param onBlock {(blockHeader: BlockHeader) => Promise<void>} callback which is called for of each block.\n   *                                                       callback may throw an error, in this case the block processing will be interrupted and block will not be saved in the storage as processed.\n   *                                                       shardchain blocks are processed OUT of chronological order.\n   *                                                       masterchain blocks are processed in chronological order.\n   *                                                       for masterchain workchain === -1 and shardId === '-9223372036854775808'\n   * @param options? {startMcBlockNumber:? number, mcInterval?: number, shardsInterval?: number} start masterchain block number from which we start to process blocks.\n   *                                     if not specified, the subscription starts from the last block of the network at the time of launch.\n   */\n  constructor(provider, storage, onBlock, options) {\n    this.provider = provider;\n    this.storage = storage;\n    this.onBlock = onBlock;\n    this.startMcBlockNumber = options ? options.startMcBlockNumber : undefined;\n    this.mcInterval = (options ? options.mcInterval : undefined) || MC_INTERVAL;\n    this.shardsInterval = (options ? options.shardsInterval : undefined) || SHARDS_INTERVAL;\n  }\n\n  async start() {\n    this.stop();\n\n    if (!this.startMcBlockNumber) {\n      this.startMcBlockNumber = (await this.provider.getMasterchainInfo()).last.seqno;\n      if (!this.startMcBlockNumber) throw new Error('Cannot get start mc block number from provider');\n    }\n\n    const startMcBlockHeader = await this.provider.getMasterchainBlockHeader(this.startMcBlockNumber);\n    this.startLT = startMcBlockHeader.end_lt;\n    if (!this.startLT) throw new Error('Cannot get startLT from provider'); // MASTERCHAIN\n\n    let isMcProcessing = false;\n\n    const mcTick = async () => {\n      if (isMcProcessing) return;\n      isMcProcessing = true;\n\n      try {\n        const lastSavedMcBlock = (await this.storage.getLastMasterchainBlockNumber()) || this.startMcBlockNumber;\n        if (!lastSavedMcBlock) throw new Error('no init masterchain block in storage');\n        const lastMcBlock = (await this.provider.getMasterchainInfo()).last.seqno;\n        if (!lastMcBlock) throw new Error('invalid last masterchain block from provider');\n\n        for (let i = lastSavedMcBlock + 1; i < lastMcBlock; i++) {\n          const blockShards = await this.provider.getBlockShards(i);\n          const blockHeader = await this.provider.getMasterchainBlockHeader(i);\n          await this.onBlock(blockHeader, blockShards);\n          await this.storage.insertBlocks(i, blockShards.shards.map(parseShardBlockNumber));\n        }\n      } catch (e) {\n        console.error(e);\n      }\n\n      isMcProcessing = false;\n    };\n\n    this.mcIntervalId = setInterval(() => mcTick(), this.mcInterval);\n    mcTick(); // SHARDCHAINS\n\n    let isShardsProcessing = false;\n\n    const shardsTick = async () => {\n      if (isShardsProcessing) return;\n      isShardsProcessing = true;\n\n      try {\n        const shardBlock = await this.storage.getUnprocessedShardBlock();\n\n        if (shardBlock) {\n          const {\n            workchain,\n            shardId,\n            shardBlockNumber\n          } = shardBlock;\n          const blockHeader = await this.provider.getBlockHeader(workchain, shardId, shardBlockNumber);\n\n          if (blockHeader.end_lt < this.startLT) {\n            await this.storage.setBlockProcessed(workchain, shardId, shardBlockNumber, []);\n          } else {\n            await this.onBlock(blockHeader);\n            const prevBlocks = blockHeader.prev_blocks.map(parseShardBlockNumber);\n            await this.storage.setBlockProcessed(workchain, shardId, shardBlockNumber, prevBlocks);\n          }\n        }\n      } catch (e) {\n        console.log(e);\n      }\n\n      isShardsProcessing = false;\n    };\n\n    this.shardsIntervalId = setInterval(() => shardsTick(), this.shardsInterval);\n  }\n\n  stop() {\n    clearInterval(this.mcIntervalId);\n    clearInterval(this.shardsIntervalId);\n  }\n\n}\n\nmodule.exports = {\n  BlockSubscription\n};","map":{"version":3,"names":["MC_INTERVAL","SHARDS_INTERVAL","parseShardBlockNumber","x","workchain","shardId","shard","shardBlockNumber","seqno","BlockSubscription","constructor","provider","storage","onBlock","options","startMcBlockNumber","undefined","mcInterval","shardsInterval","start","stop","getMasterchainInfo","last","Error","startMcBlockHeader","getMasterchainBlockHeader","startLT","end_lt","isMcProcessing","mcTick","lastSavedMcBlock","getLastMasterchainBlockNumber","lastMcBlock","i","blockShards","getBlockShards","blockHeader","insertBlocks","shards","map","e","console","error","mcIntervalId","setInterval","isShardsProcessing","shardsTick","shardBlock","getUnprocessedShardBlock","getBlockHeader","setBlockProcessed","prevBlocks","prev_blocks","log","shardsIntervalId","clearInterval","module","exports"],"sources":["/home/rybakisa/Desktop/TEMP/HackaTON/TON Ads/ton-ads/node_modules/tonweb/src/providers/blockSubscription/BlockSubscription.js"],"sourcesContent":["// NOTE: \"mc\" means masterchain, \"shards\" means shardchains\n\nconst MC_INTERVAL = 10 * 1000;\nconst SHARDS_INTERVAL = 1 * 1000;\n\nconst parseShardBlockNumber = x => {\n    return {\n        workchain: x.workchain,\n        shardId: x.shard,\n        shardBlockNumber: x.seqno\n    }\n}\n\nclass BlockSubscription {\n\n    /**\n     * @param provider  {TonWeb.HttpProvider}\n     * @param storage   persistent storage for storing block numbers that we have already processed.\n     * @param onBlock {(blockHeader: BlockHeader) => Promise<void>} callback which is called for of each block.\n     *                                                       callback may throw an error, in this case the block processing will be interrupted and block will not be saved in the storage as processed.\n     *                                                       shardchain blocks are processed OUT of chronological order.\n     *                                                       masterchain blocks are processed in chronological order.\n     *                                                       for masterchain workchain === -1 and shardId === '-9223372036854775808'\n     * @param options? {startMcBlockNumber:? number, mcInterval?: number, shardsInterval?: number} start masterchain block number from which we start to process blocks.\n     *                                     if not specified, the subscription starts from the last block of the network at the time of launch.\n     */\n    constructor(provider, storage, onBlock, options) {\n        this.provider = provider;\n        this.storage = storage;\n        this.onBlock = onBlock;\n        this.startMcBlockNumber = options ? options.startMcBlockNumber : undefined;\n        this.mcInterval = (options ? options.mcInterval : undefined) || MC_INTERVAL;\n        this.shardsInterval = (options ? options.shardsInterval : undefined) || SHARDS_INTERVAL;\n    }\n\n    async start() {\n        this.stop();\n\n        if (!this.startMcBlockNumber) {\n            this.startMcBlockNumber = (await this.provider.getMasterchainInfo()).last.seqno;\n            if (!this.startMcBlockNumber) throw new Error('Cannot get start mc block number from provider');\n        }\n        const startMcBlockHeader = await this.provider.getMasterchainBlockHeader(this.startMcBlockNumber);\n        this.startLT = startMcBlockHeader.end_lt;\n        if (!this.startLT) throw new Error('Cannot get startLT from provider');\n\n        // MASTERCHAIN\n\n        let isMcProcessing = false;\n\n        const mcTick = async () => {\n            if (isMcProcessing) return;\n\n            isMcProcessing = true;\n\n            try {\n                const lastSavedMcBlock = await this.storage.getLastMasterchainBlockNumber() || this.startMcBlockNumber;\n                if (!lastSavedMcBlock) throw new Error('no init masterchain block in storage');\n                const lastMcBlock = (await this.provider.getMasterchainInfo()).last.seqno;\n                if (!lastMcBlock) throw new Error('invalid last masterchain block from provider');\n\n                for (let i = lastSavedMcBlock + 1; i < lastMcBlock; i++) {\n                    const blockShards = await this.provider.getBlockShards(i);\n                    const blockHeader = await this.provider.getMasterchainBlockHeader(i);\n                    await this.onBlock(blockHeader, blockShards);\n                    await this.storage.insertBlocks(i, blockShards.shards.map(parseShardBlockNumber));\n                }\n            } catch (e) {\n                console.error(e);\n            }\n\n            isMcProcessing = false;\n        }\n\n        this.mcIntervalId = setInterval(() => mcTick(), this.mcInterval);\n        mcTick();\n\n        // SHARDCHAINS\n\n        let isShardsProcessing = false;\n\n        const shardsTick = async () => {\n            if (isShardsProcessing) return;\n\n            isShardsProcessing = true;\n            try {\n                const shardBlock = await this.storage.getUnprocessedShardBlock();\n                if (shardBlock) {\n                    const {workchain, shardId, shardBlockNumber} = shardBlock;\n                    const blockHeader = await this.provider.getBlockHeader(workchain, shardId, shardBlockNumber);\n                    if (blockHeader.end_lt < this.startLT) {\n                        await this.storage.setBlockProcessed(workchain, shardId, shardBlockNumber, []);\n                    } else {\n                        await this.onBlock(blockHeader);\n                        const prevBlocks = blockHeader.prev_blocks.map(parseShardBlockNumber);\n                        await this.storage.setBlockProcessed(workchain, shardId, shardBlockNumber, prevBlocks);\n                    }\n                }\n            } catch (e) {\n                console.log(e);\n            }\n            isShardsProcessing = false;\n        }\n\n        this.shardsIntervalId = setInterval(() => shardsTick(), this.shardsInterval);\n    }\n\n    stop() {\n        clearInterval(this.mcIntervalId);\n        clearInterval(this.shardsIntervalId);\n    }\n}\n\nmodule.exports = {BlockSubscription};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}