{"ast":null,"code":"const {\n  BitString\n} = require(\"./BitString\");\n\nconst {\n  bytesToBase64,\n  compareBytes,\n  concatBytes,\n  crc32c,\n  hexToBytes,\n  readNBytesUIntFromArray,\n  sha256,\n  bytesToHex\n} = require(\"../utils\");\n\nconst reachBocMagicPrefix = hexToBytes('B5EE9C72');\nconst leanBocMagicPrefix = hexToBytes('68ff65f3');\nconst leanBocMagicPrefixCRC = hexToBytes('acc3a728');\n\nclass Cell {\n  constructor() {\n    this.bits = new BitString(1023);\n    this.refs = [];\n    this.isExotic = false;\n  }\n  /**\n   * @param serializedBoc  {string | Uint8Array} hex or bytearray\n   * @return {Cell[]} root cells\n   */\n\n\n  static fromBoc(serializedBoc) {\n    return deserializeBoc(serializedBoc);\n  }\n  /**\n   * @param serializedBoc  {string | Uint8Array} hex or bytearray\n   * @return {Cell} root cell\n   */\n\n\n  static oneFromBoc(serializedBoc) {\n    const cells = deserializeBoc(serializedBoc);\n    if (cells.length !== 1) throw new Error('expected 1 root cell but have ' + cells.length);\n    return cells[0];\n  }\n  /**\n   * Write another cell to this cell\n   * @param anotherCell  {Cell}\n   */\n\n\n  writeCell(anotherCell) {\n    // XXX we do not check that there are anough place in cell\n    this.bits.writeBitString(anotherCell.bits);\n    this.refs = this.refs.concat(anotherCell.refs);\n  }\n  /**\n   * @return {number}\n   */\n\n\n  getMaxLevel() {\n    //TODO level calculation differ for exotic cells\n    let maxLevel = 0;\n\n    for (let k in this.refs) {\n      const i = this.refs[k];\n\n      if (i.getMaxLevel() > maxLevel) {\n        maxLevel = i.getMaxLevel();\n      }\n    }\n\n    return maxLevel;\n  }\n  /**\n   * @return {number}\n   */\n\n\n  isExplicitlyStoredHashes() {\n    return 0;\n  }\n  /**\n   * @return {number}\n   */\n\n\n  getMaxDepth() {\n    let maxDepth = 0;\n\n    if (this.refs.length > 0) {\n      for (let k in this.refs) {\n        const i = this.refs[k];\n\n        if (i.getMaxDepth() > maxDepth) {\n          maxDepth = i.getMaxDepth();\n        }\n      }\n\n      maxDepth = maxDepth + 1;\n    }\n\n    return maxDepth;\n  }\n  /**\n   * @private\n   * @return {Uint8Array}\n   */\n\n\n  getMaxDepthAsArray() {\n    const maxDepth = this.getMaxDepth();\n    const d = Uint8Array.from({\n      length: 2\n    }, () => 0);\n    d[1] = maxDepth % 256;\n    d[0] = Math.floor(maxDepth / 256);\n    return d;\n  }\n  /**\n   * @return {Uint8Array}\n   */\n\n\n  getRefsDescriptor() {\n    const d1 = Uint8Array.from({\n      length: 1\n    }, () => 0);\n    d1[0] = this.refs.length + this.isExotic * 8 + this.getMaxLevel() * 32;\n    return d1;\n  }\n  /**\n   * @return {Uint8Array}\n   */\n\n\n  getBitsDescriptor() {\n    const d2 = Uint8Array.from({\n      length: 1\n    }, () => 0);\n    d2[0] = Math.ceil(this.bits.cursor / 8) + Math.floor(this.bits.cursor / 8);\n    return d2;\n  }\n  /**\n   * @return {Uint8Array}\n   */\n\n\n  getDataWithDescriptors() {\n    const d1 = this.getRefsDescriptor();\n    const d2 = this.getBitsDescriptor();\n    const tuBits = this.bits.getTopUppedArray();\n    return concatBytes(concatBytes(d1, d2), tuBits);\n  }\n  /**\n   * @return {Promise<Uint8Array>}\n   */\n\n\n  async getRepr() {\n    const reprArray = [];\n    reprArray.push(this.getDataWithDescriptors());\n\n    for (let k in this.refs) {\n      const i = this.refs[k];\n      reprArray.push(i.getMaxDepthAsArray());\n    }\n\n    for (let k in this.refs) {\n      const i = this.refs[k];\n      reprArray.push(await i.hash());\n    }\n\n    let x = new Uint8Array();\n\n    for (let k in reprArray) {\n      const i = reprArray[k];\n      x = concatBytes(x, i);\n    }\n\n    return x;\n  }\n  /**\n   * @return {Promise<Uint8Array>}\n   */\n\n\n  async hash() {\n    return new Uint8Array(await sha256(await this.getRepr()));\n  }\n  /**\n   * Recursively prints cell's content like Fift\n   * @return  {string}\n   */\n\n\n  print(indent) {\n    indent = indent || '';\n    let s = indent + 'x{' + this.bits.toHex() + '}\\n';\n\n    for (let k in this.refs) {\n      const i = this.refs[k];\n      s += i.print(indent + ' ');\n    }\n\n    return s;\n  } //serialized_boc#b5ee9c72 has_idx:(## 1) has_crc32c:(## 1)\n  //  has_cache_bits:(## 1) flags:(## 2) { flags = 0 }\n  //  size:(## 3) { size <= 4 }\n  //  off_bytes:(## 8) { off_bytes <= 8 }\n  //  cells:(##(size * 8))\n  //  roots:(##(size * 8)) { roots >= 1 }\n  //  absent:(##(size * 8)) { roots + absent <= cells }\n  //  tot_cells_size:(##(off_bytes * 8))\n  //  root_list:(roots * ##(size * 8))\n  //  index:has_idx?(cells * ##(off_bytes * 8))\n  //  cell_data:(tot_cells_size * [ uint8 ])\n  //  crc32c:has_crc32c?uint32\n  // = BagOfCells;\n\n  /**\n   * create boc bytearray\n   * @param has_idx? {boolean}\n   * @param hash_crc32?  {boolean}\n   * @param has_cache_bits?  {boolean}\n   * @param flags? {number}\n   * @return {Promise<Uint8Array>}\n   */\n\n\n  async toBoc() {\n    let has_idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    let hash_crc32 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let has_cache_bits = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let flags = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    const root_cell = this;\n    const allcells = await root_cell.treeWalk();\n    const topologicalOrder = allcells[0];\n    const cellsIndex = allcells[1];\n    const cells_num = topologicalOrder.length;\n    const s = cells_num.toString(2).length; // Minimal number of bits to represent reference (unused?)\n\n    const s_bytes = Math.min(Math.ceil(s / 8), 1);\n    let full_size = 0;\n    let sizeIndex = [];\n\n    for (let cell_info of topologicalOrder) {\n      //TODO it should be async map or async for\n      sizeIndex.push(full_size);\n      full_size = full_size + (await cell_info[1].bocSerializationSize(cellsIndex, s_bytes));\n    }\n\n    const offset_bits = full_size.toString(2).length; // Minimal number of bits to offset/len (unused?)\n\n    const offset_bytes = Math.max(Math.ceil(offset_bits / 8), 1);\n    const serialization = new BitString((1023 + 32 * 4 + 32 * 3) * topologicalOrder.length);\n    serialization.writeBytes(reachBocMagicPrefix);\n    serialization.writeBitArray([has_idx, hash_crc32, has_cache_bits]);\n    serialization.writeUint(flags, 2);\n    serialization.writeUint(s_bytes, 3);\n    serialization.writeUint8(offset_bytes);\n    serialization.writeUint(cells_num, s_bytes * 8);\n    serialization.writeUint(1, s_bytes * 8); // One root for now\n\n    serialization.writeUint(0, s_bytes * 8); // Complete BOCs only\n\n    serialization.writeUint(full_size, offset_bytes * 8);\n    serialization.writeUint(0, s_bytes * 8); // Root shoulh have index 0\n\n    if (has_idx) {\n      topologicalOrder.forEach((cell_data, index) => serialization.writeUint(sizeIndex[index], offset_bytes * 8));\n    }\n\n    for (let cell_info of topologicalOrder) {\n      //TODO it should be async map or async for\n      const refcell_ser = await cell_info[1].serializeForBoc(cellsIndex, s_bytes);\n      serialization.writeBytes(refcell_ser);\n    }\n\n    let ser_arr = serialization.getTopUppedArray();\n\n    if (hash_crc32) {\n      ser_arr = concatBytes(ser_arr, crc32c(ser_arr));\n    }\n\n    return ser_arr;\n  }\n  /**\n   * @private\n   * @param cellsIndex\n   * @param refSize\n   * @return {Promise<Uint8Array>}\n   */\n\n\n  async serializeForBoc(cellsIndex, refSize) {\n    const reprArray = [];\n    reprArray.push(this.getDataWithDescriptors());\n\n    if (this.isExplicitlyStoredHashes()) {\n      throw new Error(\"Cell hashes explicit storing is not implemented\");\n    }\n\n    for (let k in this.refs) {\n      const i = this.refs[k];\n      const refHash = await i.hash();\n      const refIndexInt = cellsIndex[refHash];\n      let refIndexHex = refIndexInt.toString(16);\n\n      if (refIndexHex.length % 2) {\n        refIndexHex = \"0\" + refIndexHex;\n      }\n\n      const reference = hexToBytes(refIndexHex);\n      reprArray.push(reference);\n    }\n\n    let x = new Uint8Array();\n\n    for (let k in reprArray) {\n      const i = reprArray[k];\n      x = concatBytes(x, i);\n    }\n\n    return x;\n  }\n  /**\n   * @private\n   * @param cellsIndex\n   * @param refSize\n   * @return {Promise<number>}\n   */\n\n\n  async bocSerializationSize(cellsIndex, refSize) {\n    return (await this.serializeForBoc(cellsIndex, refSize)).length;\n  }\n  /**\n   * @private\n   * @return {[[], {}]} topologicalOrderArray and indexHashmap\n   */\n\n\n  async treeWalk() {\n    return treeWalk(this, [], {});\n  }\n\n}\n\nasync function moveToTheEnd(indexHashmap, topologicalOrderArray, target) {\n  const targetIndex = indexHashmap[target];\n\n  for (let h in indexHashmap) {\n    if (indexHashmap[h] > targetIndex) {\n      indexHashmap[h] = indexHashmap[h] - 1;\n    }\n  }\n\n  indexHashmap[target] = topologicalOrderArray.length - 1;\n  const data = topologicalOrderArray.splice(targetIndex, 1)[0];\n  topologicalOrderArray.push(data);\n\n  for (let subCell of data[1].refs) {\n    await moveToTheEnd(indexHashmap, topologicalOrderArray, await subCell.hash());\n  }\n}\n/**\n * @param cell  {Cell}\n * @param topologicalOrderArray array of pairs: cellHash: Uint8Array, cell: Cell, ...\n * @param indexHashmap cellHash: Uint8Array -> cellIndex: number\n * @return {[[], {}]} topologicalOrderArray and indexHashmap\n */\n\n\nasync function treeWalk(cell, topologicalOrderArray, indexHashmap) {\n  let parentHash = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  const cellHash = await cell.hash();\n\n  if (cellHash in indexHashmap) {\n    // Duplication cell\n    //it is possible that already seen cell is a children of more deep cell\n    if (parentHash) {\n      if (indexHashmap[parentHash] > indexHashmap[cellHash]) {\n        await moveToTheEnd(indexHashmap, topologicalOrderArray, cellHash);\n      }\n    }\n\n    return [topologicalOrderArray, indexHashmap];\n  }\n\n  indexHashmap[cellHash] = topologicalOrderArray.length;\n  topologicalOrderArray.push([cellHash, cell]);\n\n  for (let subCell of cell.refs) {\n    const res = await treeWalk(subCell, topologicalOrderArray, indexHashmap, cellHash);\n    topologicalOrderArray = res[0];\n    indexHashmap = res[1];\n  }\n\n  return [topologicalOrderArray, indexHashmap];\n}\n\nfunction parseBocHeader(serializedBoc) {\n  // snake_case is used to match TON docs\n  if (serializedBoc.length < 4 + 1) throw \"Not enough bytes for magic prefix\";\n  const inputData = serializedBoc; // Save copy for crc32\n\n  const prefix = serializedBoc.slice(0, 4);\n  serializedBoc = serializedBoc.slice(4);\n  let has_idx, hash_crc32, has_cache_bits, flags, size_bytes;\n\n  if (compareBytes(prefix, reachBocMagicPrefix)) {\n    const flags_byte = serializedBoc[0];\n    has_idx = flags_byte & 128;\n    hash_crc32 = flags_byte & 64;\n    has_cache_bits = flags_byte & 32;\n    flags = (flags_byte & 16) * 2 + (flags_byte & 8);\n    size_bytes = flags_byte % 8;\n  }\n\n  if (compareBytes(prefix, leanBocMagicPrefix)) {\n    has_idx = 1;\n    hash_crc32 = 0;\n    has_cache_bits = 0;\n    flags = 0;\n    size_bytes = serializedBoc[0];\n  }\n\n  if (compareBytes(prefix, leanBocMagicPrefixCRC)) {\n    has_idx = 1;\n    hash_crc32 = 1;\n    has_cache_bits = 0;\n    flags = 0;\n    size_bytes = serializedBoc[0];\n  }\n\n  serializedBoc = serializedBoc.slice(1);\n  if (serializedBoc.length < 1 + 5 * size_bytes) throw \"Not enough bytes for encoding cells counters\";\n  const offset_bytes = serializedBoc[0];\n  serializedBoc = serializedBoc.slice(1);\n  const cells_num = readNBytesUIntFromArray(size_bytes, serializedBoc);\n  serializedBoc = serializedBoc.slice(size_bytes);\n  const roots_num = readNBytesUIntFromArray(size_bytes, serializedBoc);\n  serializedBoc = serializedBoc.slice(size_bytes);\n  const absent_num = readNBytesUIntFromArray(size_bytes, serializedBoc);\n  serializedBoc = serializedBoc.slice(size_bytes);\n  const tot_cells_size = readNBytesUIntFromArray(offset_bytes, serializedBoc);\n  serializedBoc = serializedBoc.slice(offset_bytes);\n  if (serializedBoc.length < roots_num * size_bytes) throw \"Not enough bytes for encoding root cells hashes\";\n  let root_list = [];\n\n  for (let c = 0; c < roots_num; c++) {\n    root_list.push(readNBytesUIntFromArray(size_bytes, serializedBoc));\n    serializedBoc = serializedBoc.slice(size_bytes);\n  }\n\n  let index = false;\n\n  if (has_idx) {\n    index = [];\n    if (serializedBoc.length < offset_bytes * cells_num) throw \"Not enough bytes for index encoding\";\n\n    for (let c = 0; c < cells_num; c++) {\n      index.push(readNBytesUIntFromArray(offset_bytes, serializedBoc));\n      serializedBoc = serializedBoc.slice(offset_bytes);\n    }\n  }\n\n  if (serializedBoc.length < tot_cells_size) throw \"Not enough bytes for cells data\";\n  const cells_data = serializedBoc.slice(0, tot_cells_size);\n  serializedBoc = serializedBoc.slice(tot_cells_size);\n\n  if (hash_crc32) {\n    if (serializedBoc.length < 4) throw \"Not enough bytes for crc32c hashsum\";\n    const length = inputData.length;\n    if (!compareBytes(crc32c(inputData.slice(0, length - 4)), serializedBoc.slice(0, 4))) throw \"Crc32c hashsum mismatch\";\n    serializedBoc = serializedBoc.slice(4);\n  }\n\n  if (serializedBoc.length) throw \"Too much bytes in BoC serialization\";\n  return {\n    has_idx: has_idx,\n    hash_crc32: hash_crc32,\n    has_cache_bits: has_cache_bits,\n    flags: flags,\n    size_bytes: size_bytes,\n    off_bytes: offset_bytes,\n    cells_num: cells_num,\n    roots_num: roots_num,\n    absent_num: absent_num,\n    tot_cells_size: tot_cells_size,\n    root_list: root_list,\n    index: index,\n    cells_data: cells_data\n  };\n}\n\nfunction deserializeCellData(cellData, referenceIndexSize) {\n  if (cellData.length < 2) throw \"Not enough bytes to encode cell descriptors\";\n  const d1 = cellData[0],\n        d2 = cellData[1];\n  cellData = cellData.slice(2);\n  const level = Math.floor(d1 / 32);\n  const isExotic = d1 & 8;\n  const refNum = d1 % 8;\n  const dataBytesize = Math.ceil(d2 / 2);\n  const fullfilledBytes = !(d2 % 2);\n  let cell = new Cell();\n  cell.isExotic = isExotic;\n  if (cellData.length < dataBytesize + referenceIndexSize * refNum) throw \"Not enough bytes to encode cell data\";\n  cell.bits.setTopUppedArray(cellData.slice(0, dataBytesize), fullfilledBytes);\n  cellData = cellData.slice(dataBytesize);\n\n  for (let r = 0; r < refNum; r++) {\n    cell.refs.push(readNBytesUIntFromArray(referenceIndexSize, cellData));\n    cellData = cellData.slice(referenceIndexSize);\n  }\n\n  return {\n    cell: cell,\n    residue: cellData\n  };\n}\n/**\n * @param serializedBoc  {string | Uint8Array} hex or bytearray\n * @return {Cell[]} root cells\n */\n\n\nfunction deserializeBoc(serializedBoc) {\n  if (typeof serializedBoc == 'string') {\n    serializedBoc = hexToBytes(serializedBoc);\n  }\n\n  const header = parseBocHeader(serializedBoc);\n  let cells_data = header.cells_data;\n  let cells_array = [];\n\n  for (let ci = 0; ci < header.cells_num; ci++) {\n    let dd = deserializeCellData(cells_data, header.size_bytes);\n    cells_data = dd.residue;\n    cells_array.push(dd.cell);\n  }\n\n  for (let ci = header.cells_num - 1; ci >= 0; ci--) {\n    let c = cells_array[ci];\n\n    for (let ri = 0; ri < c.refs.length; ri++) {\n      const r = c.refs[ri];\n\n      if (r < ci) {\n        throw \"Topological order is broken\";\n      }\n\n      c.refs[ri] = cells_array[r];\n    }\n  }\n\n  let root_cells = [];\n\n  for (let ri of header.root_list) {\n    root_cells.push(cells_array[ri]);\n  }\n\n  return root_cells;\n}\n\nmodule.exports = {\n  Cell\n};","map":{"version":3,"names":["BitString","require","bytesToBase64","compareBytes","concatBytes","crc32c","hexToBytes","readNBytesUIntFromArray","sha256","bytesToHex","reachBocMagicPrefix","leanBocMagicPrefix","leanBocMagicPrefixCRC","Cell","constructor","bits","refs","isExotic","fromBoc","serializedBoc","deserializeBoc","oneFromBoc","cells","length","Error","writeCell","anotherCell","writeBitString","concat","getMaxLevel","maxLevel","k","i","isExplicitlyStoredHashes","getMaxDepth","maxDepth","getMaxDepthAsArray","d","Uint8Array","from","Math","floor","getRefsDescriptor","d1","getBitsDescriptor","d2","ceil","cursor","getDataWithDescriptors","tuBits","getTopUppedArray","getRepr","reprArray","push","hash","x","print","indent","s","toHex","toBoc","has_idx","hash_crc32","has_cache_bits","flags","root_cell","allcells","treeWalk","topologicalOrder","cellsIndex","cells_num","toString","s_bytes","min","full_size","sizeIndex","cell_info","bocSerializationSize","offset_bits","offset_bytes","max","serialization","writeBytes","writeBitArray","writeUint","writeUint8","forEach","cell_data","index","refcell_ser","serializeForBoc","ser_arr","refSize","refHash","refIndexInt","refIndexHex","reference","moveToTheEnd","indexHashmap","topologicalOrderArray","target","targetIndex","h","data","splice","subCell","cell","parentHash","cellHash","res","parseBocHeader","inputData","prefix","slice","size_bytes","flags_byte","roots_num","absent_num","tot_cells_size","root_list","c","cells_data","off_bytes","deserializeCellData","cellData","referenceIndexSize","level","refNum","dataBytesize","fullfilledBytes","setTopUppedArray","r","residue","header","cells_array","ci","dd","ri","root_cells","module","exports"],"sources":["/home/rybakisa/Desktop/TEMP/HackaTON/TON Ads/ton-ads/node_modules/tonweb/src/boc/Cell.js"],"sourcesContent":["const {BitString} = require(\"./BitString\");\nconst {\n    bytesToBase64,\n    compareBytes,\n    concatBytes,\n    crc32c,\n    hexToBytes,\n    readNBytesUIntFromArray,\n    sha256,\n    bytesToHex\n} = require(\"../utils\");\n\nconst reachBocMagicPrefix = hexToBytes('B5EE9C72');\nconst leanBocMagicPrefix = hexToBytes('68ff65f3');\nconst leanBocMagicPrefixCRC = hexToBytes('acc3a728');\n\nclass Cell {\n    constructor() {\n        this.bits = new BitString(1023);\n        this.refs = [];\n        this.isExotic = false;\n    }\n\n    /**\n     * @param serializedBoc  {string | Uint8Array} hex or bytearray\n     * @return {Cell[]} root cells\n     */\n    static fromBoc(serializedBoc) {\n        return deserializeBoc(serializedBoc);\n    }\n\n    /**\n     * @param serializedBoc  {string | Uint8Array} hex or bytearray\n     * @return {Cell} root cell\n     */\n    static oneFromBoc(serializedBoc) {\n        const cells = deserializeBoc(serializedBoc);\n        if (cells.length !== 1) throw new Error('expected 1 root cell but have ' + cells.length);\n        return cells[0];\n    }\n\n    /**\n     * Write another cell to this cell\n     * @param anotherCell  {Cell}\n     */\n    writeCell(anotherCell) {\n        // XXX we do not check that there are anough place in cell\n        this.bits.writeBitString(anotherCell.bits);\n        this.refs = this.refs.concat(anotherCell.refs);\n    }\n\n    /**\n     * @return {number}\n     */\n    getMaxLevel() {\n        //TODO level calculation differ for exotic cells\n        let maxLevel = 0;\n        for (let k in this.refs) {\n            const i = this.refs[k];\n            if (i.getMaxLevel() > maxLevel) {\n                maxLevel = i.getMaxLevel();\n            }\n        }\n        return maxLevel;\n    }\n\n    /**\n     * @return {number}\n     */\n    isExplicitlyStoredHashes() {\n        return 0;\n    }\n\n    /**\n     * @return {number}\n     */\n    getMaxDepth() {\n        let maxDepth = 0;\n        if (this.refs.length > 0) {\n            for (let k in this.refs) {\n                const i = this.refs[k];\n                if (i.getMaxDepth() > maxDepth) {\n                    maxDepth = i.getMaxDepth();\n                }\n            }\n            maxDepth = maxDepth + 1;\n        }\n        return maxDepth;\n    }\n\n    /**\n     * @private\n     * @return {Uint8Array}\n     */\n    getMaxDepthAsArray() {\n        const maxDepth = this.getMaxDepth();\n        const d = Uint8Array.from({length: 2}, () => 0);\n        d[1] = maxDepth % 256;\n        d[0] = Math.floor(maxDepth / 256);\n        return d;\n    }\n\n    /**\n     * @return {Uint8Array}\n     */\n    getRefsDescriptor() {\n        const d1 = Uint8Array.from({length: 1}, () => 0);\n        d1[0] = this.refs.length + this.isExotic * 8 + this.getMaxLevel() * 32;\n        return d1;\n    }\n\n    /**\n     * @return {Uint8Array}\n     */\n    getBitsDescriptor() {\n        const d2 = Uint8Array.from({length: 1}, () => 0);\n        d2[0] = Math.ceil(this.bits.cursor / 8) + Math.floor(this.bits.cursor / 8);\n        return d2;\n    }\n\n    /**\n     * @return {Uint8Array}\n     */\n    getDataWithDescriptors() {\n        const d1 = this.getRefsDescriptor();\n        const d2 = this.getBitsDescriptor();\n        const tuBits = this.bits.getTopUppedArray();\n        return concatBytes(concatBytes(d1, d2), tuBits);\n    }\n\n    /**\n     * @return {Promise<Uint8Array>}\n     */\n    async getRepr() {\n        const reprArray = [];\n\n        reprArray.push(this.getDataWithDescriptors());\n        for (let k in this.refs) {\n            const i = this.refs[k];\n            reprArray.push(i.getMaxDepthAsArray());\n        }\n        for (let k in this.refs) {\n            const i = this.refs[k];\n            reprArray.push(await i.hash());\n        }\n        let x = new Uint8Array();\n        for (let k in reprArray) {\n            const i = reprArray[k];\n            x = concatBytes(x, i);\n        }\n        return x;\n    }\n\n    /**\n     * @return {Promise<Uint8Array>}\n     */\n    async hash() {\n        return new Uint8Array(\n            await sha256(await this.getRepr())\n        );\n    }\n\n    /**\n     * Recursively prints cell's content like Fift\n     * @return  {string}\n     */\n    print(indent) {\n        indent = indent || '';\n        let s = indent + 'x{' + this.bits.toHex() + '}\\n';\n        for (let k in this.refs) {\n            const i = this.refs[k];\n            s += i.print(indent + ' ');\n        }\n        return s;\n    }\n\n    //serialized_boc#b5ee9c72 has_idx:(## 1) has_crc32c:(## 1)\n    //  has_cache_bits:(## 1) flags:(## 2) { flags = 0 }\n    //  size:(## 3) { size <= 4 }\n    //  off_bytes:(## 8) { off_bytes <= 8 }\n    //  cells:(##(size * 8))\n    //  roots:(##(size * 8)) { roots >= 1 }\n    //  absent:(##(size * 8)) { roots + absent <= cells }\n    //  tot_cells_size:(##(off_bytes * 8))\n    //  root_list:(roots * ##(size * 8))\n    //  index:has_idx?(cells * ##(off_bytes * 8))\n    //  cell_data:(tot_cells_size * [ uint8 ])\n    //  crc32c:has_crc32c?uint32\n    // = BagOfCells;\n    /**\n     * create boc bytearray\n     * @param has_idx? {boolean}\n     * @param hash_crc32?  {boolean}\n     * @param has_cache_bits?  {boolean}\n     * @param flags? {number}\n     * @return {Promise<Uint8Array>}\n     */\n    async toBoc(has_idx = true, hash_crc32 = true, has_cache_bits = false, flags = 0) {\n        const root_cell = this;\n\n        const allcells = await root_cell.treeWalk();\n        const topologicalOrder = allcells[0];\n        const cellsIndex = allcells[1];\n\n        const cells_num = topologicalOrder.length;\n        const s = cells_num.toString(2).length; // Minimal number of bits to represent reference (unused?)\n        const s_bytes = Math.min(Math.ceil(s / 8), 1);\n        let full_size = 0;\n        let sizeIndex = [];\n        for (let cell_info of topologicalOrder) {\n            //TODO it should be async map or async for\n            sizeIndex.push(full_size);\n            full_size = full_size + await cell_info[1].bocSerializationSize(cellsIndex, s_bytes);\n        }\n        const offset_bits = full_size.toString(2).length; // Minimal number of bits to offset/len (unused?)\n        const offset_bytes = Math.max(Math.ceil(offset_bits / 8), 1);\n\n        const serialization = new BitString((1023 + 32 * 4 + 32 * 3) * topologicalOrder.length);\n        serialization.writeBytes(reachBocMagicPrefix);\n        serialization.writeBitArray([has_idx, hash_crc32, has_cache_bits]);\n        serialization.writeUint(flags, 2);\n        serialization.writeUint(s_bytes, 3);\n        serialization.writeUint8(offset_bytes);\n        serialization.writeUint(cells_num, s_bytes * 8);\n        serialization.writeUint(1, s_bytes * 8); // One root for now\n        serialization.writeUint(0, s_bytes * 8); // Complete BOCs only\n        serialization.writeUint(full_size, offset_bytes * 8);\n        serialization.writeUint(0, s_bytes * 8); // Root shoulh have index 0\n        if (has_idx) {\n            topologicalOrder.forEach(\n                (cell_data, index) =>\n                    serialization.writeUint(sizeIndex[index], offset_bytes * 8));\n        }\n        for (let cell_info of topologicalOrder) {\n            //TODO it should be async map or async for\n            const refcell_ser = await cell_info[1].serializeForBoc(cellsIndex, s_bytes);\n            serialization.writeBytes(refcell_ser);\n        }\n        let ser_arr = serialization.getTopUppedArray();\n        if (hash_crc32) {\n            ser_arr = concatBytes(ser_arr, crc32c(ser_arr));\n        }\n\n        return ser_arr;\n    }\n\n    /**\n     * @private\n     * @param cellsIndex\n     * @param refSize\n     * @return {Promise<Uint8Array>}\n     */\n    async serializeForBoc(cellsIndex, refSize) {\n        const reprArray = [];\n\n        reprArray.push(this.getDataWithDescriptors());\n        if (this.isExplicitlyStoredHashes()) {\n            throw new Error(\"Cell hashes explicit storing is not implemented\");\n        }\n        for (let k in this.refs) {\n            const i = this.refs[k];\n            const refHash = await i.hash();\n            const refIndexInt = cellsIndex[refHash];\n            let refIndexHex = refIndexInt.toString(16);\n            if (refIndexHex.length % 2) {\n                refIndexHex = \"0\" + refIndexHex;\n            }\n            const reference = hexToBytes(refIndexHex);\n            reprArray.push(reference);\n        }\n        let x = new Uint8Array();\n        for (let k in reprArray) {\n            const i = reprArray[k];\n            x = concatBytes(x, i);\n        }\n        return x;\n    }\n\n    /**\n     * @private\n     * @param cellsIndex\n     * @param refSize\n     * @return {Promise<number>}\n     */\n    async bocSerializationSize(cellsIndex, refSize) {\n        return (await this.serializeForBoc(cellsIndex, refSize)).length;\n    }\n\n    /**\n     * @private\n     * @return {[[], {}]} topologicalOrderArray and indexHashmap\n     */\n    async treeWalk() {\n        return treeWalk(this, [], {});\n    }\n}\n\nasync function moveToTheEnd(indexHashmap, topologicalOrderArray, target) {\n    const targetIndex = indexHashmap[target];\n    for (let h in indexHashmap) {\n        if (indexHashmap[h] > targetIndex) {\n            indexHashmap[h] = indexHashmap[h] - 1;\n        }\n    }\n    indexHashmap[target] = topologicalOrderArray.length - 1;\n    const data = topologicalOrderArray.splice(targetIndex, 1)[0];\n    topologicalOrderArray.push(data);\n    for (let subCell of data[1].refs) {\n        await moveToTheEnd(indexHashmap, topologicalOrderArray, await subCell.hash());\n    }\n}\n\n/**\n * @param cell  {Cell}\n * @param topologicalOrderArray array of pairs: cellHash: Uint8Array, cell: Cell, ...\n * @param indexHashmap cellHash: Uint8Array -> cellIndex: number\n * @return {[[], {}]} topologicalOrderArray and indexHashmap\n */\nasync function treeWalk(cell, topologicalOrderArray, indexHashmap, parentHash = null) {\n    const cellHash = await cell.hash();\n    if (cellHash in indexHashmap) { // Duplication cell\n        //it is possible that already seen cell is a children of more deep cell\n        if (parentHash) {\n            if (indexHashmap[parentHash] > indexHashmap[cellHash]) {\n                await moveToTheEnd(indexHashmap, topologicalOrderArray, cellHash);\n            }\n        }\n        return [topologicalOrderArray, indexHashmap];\n    }\n    indexHashmap[cellHash] = topologicalOrderArray.length;\n    topologicalOrderArray.push([cellHash, cell]);\n    for (let subCell of cell.refs) {\n        const res = await treeWalk(subCell, topologicalOrderArray, indexHashmap, cellHash);\n        topologicalOrderArray = res[0];\n        indexHashmap = res[1];\n    }\n\n    return [topologicalOrderArray, indexHashmap];\n}\n\n\nfunction parseBocHeader(serializedBoc) {\n    // snake_case is used to match TON docs\n    if (serializedBoc.length < 4 + 1)\n        throw \"Not enough bytes for magic prefix\";\n    const inputData = serializedBoc; // Save copy for crc32\n    const prefix = serializedBoc.slice(0, 4);\n    serializedBoc = serializedBoc.slice(4);\n    let has_idx, hash_crc32, has_cache_bits, flags, size_bytes;\n    if (compareBytes(prefix, reachBocMagicPrefix)) {\n        const flags_byte = serializedBoc[0];\n        has_idx = flags_byte & 128;\n        hash_crc32 = flags_byte & 64;\n        has_cache_bits = flags_byte & 32;\n        flags = (flags_byte & 16) * 2 + (flags_byte & 8);\n        size_bytes = flags_byte % 8;\n    }\n    if (compareBytes(prefix, leanBocMagicPrefix)) {\n        has_idx = 1;\n        hash_crc32 = 0;\n        has_cache_bits = 0;\n        flags = 0;\n        size_bytes = serializedBoc[0];\n    }\n    if (compareBytes(prefix, leanBocMagicPrefixCRC)) {\n        has_idx = 1;\n        hash_crc32 = 1;\n        has_cache_bits = 0;\n        flags = 0;\n        size_bytes = serializedBoc[0];\n    }\n    serializedBoc = serializedBoc.slice(1);\n    if (serializedBoc.length < 1 + 5 * size_bytes)\n        throw \"Not enough bytes for encoding cells counters\";\n    const offset_bytes = serializedBoc[0];\n    serializedBoc = serializedBoc.slice(1);\n    const cells_num = readNBytesUIntFromArray(size_bytes, serializedBoc);\n    serializedBoc = serializedBoc.slice(size_bytes);\n    const roots_num = readNBytesUIntFromArray(size_bytes, serializedBoc);\n    serializedBoc = serializedBoc.slice(size_bytes);\n    const absent_num = readNBytesUIntFromArray(size_bytes, serializedBoc);\n    serializedBoc = serializedBoc.slice(size_bytes);\n    const tot_cells_size = readNBytesUIntFromArray(offset_bytes, serializedBoc);\n    serializedBoc = serializedBoc.slice(offset_bytes);\n    if (serializedBoc.length < roots_num * size_bytes)\n        throw \"Not enough bytes for encoding root cells hashes\";\n    let root_list = [];\n    for (let c = 0; c < roots_num; c++) {\n        root_list.push(readNBytesUIntFromArray(size_bytes, serializedBoc));\n        serializedBoc = serializedBoc.slice(size_bytes);\n    }\n    let index = false;\n    if (has_idx) {\n        index = [];\n        if (serializedBoc.length < offset_bytes * cells_num)\n            throw \"Not enough bytes for index encoding\";\n        for (let c = 0; c < cells_num; c++) {\n            index.push(readNBytesUIntFromArray(offset_bytes, serializedBoc));\n            serializedBoc = serializedBoc.slice(offset_bytes);\n        }\n    }\n\n    if (serializedBoc.length < tot_cells_size)\n        throw \"Not enough bytes for cells data\";\n    const cells_data = serializedBoc.slice(0, tot_cells_size);\n    serializedBoc = serializedBoc.slice(tot_cells_size);\n    if (hash_crc32) {\n        if (serializedBoc.length < 4)\n            throw \"Not enough bytes for crc32c hashsum\";\n        const length = inputData.length;\n        if (!compareBytes(crc32c(inputData.slice(0, length - 4)), serializedBoc.slice(0, 4)))\n            throw \"Crc32c hashsum mismatch\";\n        serializedBoc = serializedBoc.slice(4);\n    }\n    if (serializedBoc.length)\n        throw \"Too much bytes in BoC serialization\";\n    return {\n        has_idx: has_idx, hash_crc32: hash_crc32, has_cache_bits: has_cache_bits, flags: flags, size_bytes: size_bytes,\n        off_bytes: offset_bytes, cells_num: cells_num, roots_num: roots_num, absent_num: absent_num,\n        tot_cells_size: tot_cells_size, root_list: root_list, index: index,\n        cells_data: cells_data\n    };\n}\n\nfunction deserializeCellData(cellData, referenceIndexSize) {\n    if (cellData.length < 2)\n        throw \"Not enough bytes to encode cell descriptors\";\n    const d1 = cellData[0], d2 = cellData[1];\n    cellData = cellData.slice(2);\n    const level = Math.floor(d1 / 32);\n    const isExotic = d1 & 8;\n    const refNum = d1 % 8;\n    const dataBytesize = Math.ceil(d2 / 2);\n    const fullfilledBytes = !(d2 % 2);\n    let cell = new Cell();\n    cell.isExotic = isExotic;\n    if (cellData.length < dataBytesize + referenceIndexSize * refNum)\n        throw \"Not enough bytes to encode cell data\";\n    cell.bits.setTopUppedArray(cellData.slice(0, dataBytesize), fullfilledBytes);\n    cellData = cellData.slice(dataBytesize);\n    for (let r = 0; r < refNum; r++) {\n        cell.refs.push(readNBytesUIntFromArray(referenceIndexSize, cellData));\n        cellData = cellData.slice(referenceIndexSize);\n    }\n    return {cell: cell, residue: cellData};\n}\n\n\n/**\n * @param serializedBoc  {string | Uint8Array} hex or bytearray\n * @return {Cell[]} root cells\n */\nfunction deserializeBoc(serializedBoc) {\n    if (typeof (serializedBoc) == 'string') {\n        serializedBoc = hexToBytes(serializedBoc);\n    }\n    const header = parseBocHeader(serializedBoc);\n    let cells_data = header.cells_data;\n    let cells_array = [];\n    for (let ci = 0; ci < header.cells_num; ci++) {\n        let dd = deserializeCellData(cells_data, header.size_bytes);\n        cells_data = dd.residue;\n        cells_array.push(dd.cell);\n    }\n    for (let ci = header.cells_num - 1; ci >= 0; ci--) {\n        let c = cells_array[ci];\n        for (let ri = 0; ri < c.refs.length; ri++) {\n            const r = c.refs[ri];\n            if (r < ci) {\n                throw \"Topological order is broken\";\n            }\n            c.refs[ri] = cells_array[r];\n        }\n    }\n    let root_cells = [];\n    for (let ri of header.root_list) {\n        root_cells.push(cells_array[ri]);\n    }\n    return root_cells;\n}\n\nmodule.exports = {Cell};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}