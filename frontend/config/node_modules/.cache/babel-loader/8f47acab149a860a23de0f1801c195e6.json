{"ast":null,"code":"const {\n  parseAddress\n} = require(\"../token/nft/NftUtils\");\n\nconst {\n  BN,\n  sha256,\n  bytesToHex,\n  bytesToBase64\n} = require(\"../../utils\");\n\nconst {\n  Cell\n} = require(\"../../boc\");\n\nconst DNS_CATEGORY_NEXT_RESOLVER = 'dns_next_resolver'; // Smart Contract address\n\nconst DNS_CATEGORY_WALLET = 'wallet'; // Smart Contract address\n\nconst DNS_CATEGORY_SITE = 'site'; // ADNL address\n\n/**\n * @param category  {string | undefined}\n * @return  {BN}\n */\n\nconst categoryToBN = async category => {\n  if (!category) return new BN(0); // all categories\n\n  const categoryBytes = new TextEncoder().encode(category);\n  const categoryHash = new Uint8Array(await sha256(categoryBytes));\n  return new BN(bytesToHex(categoryHash), 16);\n};\n/**\n * @param smartContractAddress   {Address}\n * @return {Cell}\n */\n\n\nconst createSmartContractAddressRecord = smartContractAddress => {\n  const cell = new Cell();\n  cell.bits.writeUint(0x9fd3, 16); // https://github.com/ton-blockchain/ton/blob/7e3df93ca2ab336716a230fceb1726d81bac0a06/crypto/block/block.tlb#L827\n\n  cell.bits.writeAddress(smartContractAddress);\n  cell.bits.writeUint(0, 8); // flags\n\n  return cell;\n};\n/**\n * @param adnlAddress   {BN}\n * @return {Cell}\n */\n\n\nconst createAdnlAddressRecord = adnlAddress => {\n  const cell = new Cell();\n  cell.bits.writeUint(0xad01, 16); // https://github.com/ton-blockchain/ton/blob/7e3df93ca2ab336716a230fceb1726d81bac0a06/crypto/block/block.tlb#L821\n\n  cell.bits.writeUint(adnlAddress, 256);\n  cell.bits.writeUint(0, 8); // flags\n\n  return cell;\n};\n/**\n * @param smartContractAddress   {Address}\n * @return {Cell}\n */\n\n\nconst createNextResolverRecord = smartContractAddress => {\n  const cell = new Cell();\n  cell.bits.writeUint(0xba93, 16); // https://github.com/ton-blockchain/ton/blob/7e3df93ca2ab336716a230fceb1726d81bac0a06/crypto/block/block.tlb#L819\n\n  cell.bits.writeAddress(smartContractAddress);\n  return cell;\n};\n/**\n * @private\n * @param cell  {Cell}\n * @param prefix0 {number}\n * @param prefix1 {number}\n * @return {Address|null}\n */\n\n\nconst parseSmartContractAddressImpl = (cell, prefix0, prefix1) => {\n  if (cell.bits.array[0] !== prefix0 || cell.bits.array[1] !== prefix1) throw new Error('Invalid dns record value prefix');\n  cell.bits.array = cell.bits.array.slice(2); // skip prefix - first 16 bits\n\n  return parseAddress(cell);\n};\n/**\n * @param cell  {Cell}\n * @return {Address|null}\n */\n\n\nconst parseSmartContractAddressRecord = cell => {\n  return parseSmartContractAddressImpl(cell, 0x9f, 0xd3);\n};\n/**\n * @param cell  {Cell}\n * @return {Address|null}\n */\n\n\nconst parseNextResolverRecord = cell => {\n  return parseSmartContractAddressImpl(cell, 0xba, 0x93);\n};\n/**\n * @private\n * @param provider  {HttpProvider}\n * @param dnsAddress   {string} address of dns smart contract\n * @param rawDomainBytes {Uint8Array}\n * @param category  {string | undefined} category of requested DNS record\n * @param oneStep {boolean | undefined} non-recursive\n * @returns {Promise<Cell | Address | BN | null>}\n */\n\n\nconst dnsResolveImpl = async (provider, dnsAddress, rawDomainBytes, category, oneStep) => {\n  const len = rawDomainBytes.length * 8;\n  const domainCell = new Cell();\n  domainCell.bits.writeBytes(rawDomainBytes);\n  const categoryBN = await categoryToBN(category);\n  const result = await provider.call2(dnsAddress, 'dnsresolve', [['tvm.Slice', bytesToBase64(await domainCell.toBoc(false))], ['num', categoryBN.toString()]]);\n\n  if (result.length !== 2) {\n    throw new Error('Invalid dnsresolve response');\n  }\n\n  const resultLen = result[0].toNumber();\n  let cell = result[1];\n\n  if (cell instanceof Array && cell.length === 0) {\n    cell = null;\n  }\n\n  if (cell && !cell.bits) {\n    // not a Cell\n    throw new Error('Invalid dnsresolve response');\n  }\n\n  if (resultLen === 0) {\n    return null; // domain cannot be resolved\n  }\n\n  if (resultLen % 8 !== 0) {\n    throw new Error('domain split not at a component boundary');\n  } // if (rawDomainBytes[resultLen] !== 0) {\n  //     throw new Error('domain split not at a component boundary');\n  // }\n\n\n  if (resultLen > len) {\n    throw new Error('invalid response ' + resultLen + '/' + len);\n  } else if (resultLen === len) {\n    if (category === DNS_CATEGORY_NEXT_RESOLVER) {\n      return cell ? parseNextResolverRecord(cell) : null;\n    } else if (category === DNS_CATEGORY_WALLET) {\n      return cell ? parseSmartContractAddressRecord(cell) : null;\n    } else if (category === DNS_CATEGORY_SITE) {\n      return cell ? cell : null; // todo: convert to BN;\n    } else {\n      return cell;\n    }\n  } else {\n    if (!cell) {\n      return null; // domain cannot be resolved\n    } else {\n      const nextAddress = parseNextResolverRecord(cell);\n\n      if (oneStep) {\n        if (category === DNS_CATEGORY_NEXT_RESOLVER) {\n          return nextAddress;\n        } else {\n          return null;\n        }\n      } else {\n        return await dnsResolveImpl(provider, nextAddress.toString(), rawDomainBytes.slice(resultLen / 8), category, false);\n      }\n    }\n  }\n};\n/**\n * Verify and convert domain\n * @param domain    {string}\n * @return {Uint8Array}\n */\n\n\nconst domainToBytes = domain => {\n  if (!domain || !domain.length) {\n    throw new Error('empty domain');\n  }\n\n  if (domain === '.') {\n    return new Uint8Array([0]);\n  }\n\n  domain = domain.toLowerCase();\n\n  for (let i = 0; i < domain.length; i++) {\n    if (domain.charCodeAt(i) <= 32) {\n      throw new Error('bytes in range 0..32 are not allowed in domain names');\n    }\n  }\n\n  for (let i = 0; i < domain.length; i++) {\n    const s = domain.substring(i, i + 1);\n\n    for (let c = 127; c <= 159; c++) {\n      // another control codes range\n      if (s === String.fromCharCode(c)) {\n        throw new Error('bytes in range 127..159 are not allowed in domain names');\n      }\n    }\n  }\n\n  const arr = domain.split('.');\n  arr.forEach(part => {\n    if (!part.length) {\n      throw new Error('domain name cannot have an empty component');\n    }\n  });\n  const rawDomain = '\\0' + arr.reverse().join('\\0') + '\\0';\n  return new TextEncoder().encode(rawDomain);\n};\n/**\n * @param provider  {HttpProvider}\n * @param rootDnsAddress {string} address of root DNS smart contract\n * @param domain    {string} e.g \"sub.alice.ton\"\n * @param category  {string | undefined} category of requested DNS record\n * @param oneStep {boolean | undefined} non-recursive\n * @returns {Promise<Cell | Address | BN | null>}\n */\n\n\nconst dnsResolve = async (provider, rootDnsAddress, domain, category, oneStep) => {\n  const rawDomainBytes = domainToBytes(domain);\n  return dnsResolveImpl(provider, rootDnsAddress, rawDomainBytes, category, oneStep);\n};\n\nmodule.exports = {\n  DNS_CATEGORY_NEXT_RESOLVER,\n  DNS_CATEGORY_SITE,\n  DNS_CATEGORY_WALLET,\n  categoryToBN,\n  domainToBytes,\n  createSmartContractAddressRecord,\n  createAdnlAddressRecord,\n  createNextResolverRecord,\n  parseNextResolverRecord,\n  parseSmartContractAddressRecord,\n  dnsResolve\n};","map":{"version":3,"names":["parseAddress","require","BN","sha256","bytesToHex","bytesToBase64","Cell","DNS_CATEGORY_NEXT_RESOLVER","DNS_CATEGORY_WALLET","DNS_CATEGORY_SITE","categoryToBN","category","categoryBytes","TextEncoder","encode","categoryHash","Uint8Array","createSmartContractAddressRecord","smartContractAddress","cell","bits","writeUint","writeAddress","createAdnlAddressRecord","adnlAddress","createNextResolverRecord","parseSmartContractAddressImpl","prefix0","prefix1","array","Error","slice","parseSmartContractAddressRecord","parseNextResolverRecord","dnsResolveImpl","provider","dnsAddress","rawDomainBytes","oneStep","len","length","domainCell","writeBytes","categoryBN","result","call2","toBoc","toString","resultLen","toNumber","Array","nextAddress","domainToBytes","domain","toLowerCase","i","charCodeAt","s","substring","c","String","fromCharCode","arr","split","forEach","part","rawDomain","reverse","join","dnsResolve","rootDnsAddress","module","exports"],"sources":["/home/rybakisa/Desktop/TEMP/HackaTON/TON Ads/ton-ads/node_modules/tonweb/src/contract/dns/DnsUtils.js"],"sourcesContent":["const {parseAddress} = require(\"../token/nft/NftUtils\");\nconst {BN, sha256, bytesToHex, bytesToBase64} = require(\"../../utils\");\nconst {Cell} = require(\"../../boc\");\n\nconst DNS_CATEGORY_NEXT_RESOLVER = 'dns_next_resolver'; // Smart Contract address\nconst DNS_CATEGORY_WALLET = 'wallet'; // Smart Contract address\nconst DNS_CATEGORY_SITE = 'site'; // ADNL address\n\n/**\n * @param category  {string | undefined}\n * @return  {BN}\n */\nconst categoryToBN = async (category) => {\n    if (!category) return new BN(0); // all categories\n    const categoryBytes = new TextEncoder().encode(category);\n    const categoryHash = new Uint8Array(await sha256(categoryBytes));\n    return new BN(bytesToHex(categoryHash), 16);\n}\n\n/**\n * @param smartContractAddress   {Address}\n * @return {Cell}\n */\nconst createSmartContractAddressRecord = (smartContractAddress) => {\n    const cell = new Cell();\n    cell.bits.writeUint(0x9fd3, 16); // https://github.com/ton-blockchain/ton/blob/7e3df93ca2ab336716a230fceb1726d81bac0a06/crypto/block/block.tlb#L827\n    cell.bits.writeAddress(smartContractAddress);\n    cell.bits.writeUint(0, 8); // flags\n    return cell;\n}\n\n/**\n * @param adnlAddress   {BN}\n * @return {Cell}\n */\nconst createAdnlAddressRecord = (adnlAddress) => {\n    const cell = new Cell();\n    cell.bits.writeUint(0xad01, 16); // https://github.com/ton-blockchain/ton/blob/7e3df93ca2ab336716a230fceb1726d81bac0a06/crypto/block/block.tlb#L821\n    cell.bits.writeUint(adnlAddress, 256);\n    cell.bits.writeUint(0, 8); // flags\n    return cell;\n}\n\n/**\n * @param smartContractAddress   {Address}\n * @return {Cell}\n */\nconst createNextResolverRecord = (smartContractAddress) => {\n    const cell = new Cell();\n    cell.bits.writeUint(0xba93, 16); // https://github.com/ton-blockchain/ton/blob/7e3df93ca2ab336716a230fceb1726d81bac0a06/crypto/block/block.tlb#L819\n    cell.bits.writeAddress(smartContractAddress);\n    return cell;\n}\n\n/**\n * @private\n * @param cell  {Cell}\n * @param prefix0 {number}\n * @param prefix1 {number}\n * @return {Address|null}\n */\nconst parseSmartContractAddressImpl = (cell, prefix0, prefix1) => {\n    if (cell.bits.array[0] !== prefix0 || cell.bits.array[1] !== prefix1) throw new Error('Invalid dns record value prefix');\n    cell.bits.array = cell.bits.array.slice(2); // skip prefix - first 16 bits\n    return parseAddress(cell);\n}\n\n/**\n * @param cell  {Cell}\n * @return {Address|null}\n */\nconst parseSmartContractAddressRecord = (cell) => {\n    return parseSmartContractAddressImpl(cell, 0x9f, 0xd3);\n}\n\n/**\n * @param cell  {Cell}\n * @return {Address|null}\n */\nconst parseNextResolverRecord = (cell) => {\n    return parseSmartContractAddressImpl(cell, 0xba, 0x93);\n}\n\n/**\n * @private\n * @param provider  {HttpProvider}\n * @param dnsAddress   {string} address of dns smart contract\n * @param rawDomainBytes {Uint8Array}\n * @param category  {string | undefined} category of requested DNS record\n * @param oneStep {boolean | undefined} non-recursive\n * @returns {Promise<Cell | Address | BN | null>}\n */\nconst dnsResolveImpl = async (provider, dnsAddress, rawDomainBytes, category, oneStep) => {\n    const len = rawDomainBytes.length * 8;\n\n    const domainCell = new Cell();\n    domainCell.bits.writeBytes(rawDomainBytes);\n\n    const categoryBN = await categoryToBN(category);\n    const result = await provider.call2(dnsAddress, 'dnsresolve', [['tvm.Slice', bytesToBase64(await domainCell.toBoc(false))], ['num', categoryBN.toString()]]);\n    if (result.length !== 2) {\n        throw new Error('Invalid dnsresolve response');\n    }\n    const resultLen = result[0].toNumber();\n\n    let cell = result[1];\n    if ((cell instanceof Array) && cell.length === 0) {\n        cell = null;\n    }\n\n    if (cell && !cell.bits) { // not a Cell\n        throw new Error('Invalid dnsresolve response');\n    }\n\n    if (resultLen === 0) {\n        return null;  // domain cannot be resolved\n    }\n\n    if (resultLen % 8 !== 0) {\n        throw new Error('domain split not at a component boundary');\n    }\n    // if (rawDomainBytes[resultLen] !== 0) {\n    //     throw new Error('domain split not at a component boundary');\n    // }\n    if (resultLen > len) {\n        throw new Error('invalid response ' + resultLen + '/' + len);\n    } else if (resultLen === len) {\n        if (category === DNS_CATEGORY_NEXT_RESOLVER) {\n            return cell ? parseNextResolverRecord(cell) : null;\n        } else if (category === DNS_CATEGORY_WALLET) {\n            return cell ? parseSmartContractAddressRecord(cell) : null;\n        } else if (category === DNS_CATEGORY_SITE) {\n            return cell ? cell : null // todo: convert to BN;\n        } else {\n            return cell;\n        }\n    } else {\n        if (!cell) {\n            return null; // domain cannot be resolved\n        } else {\n            const nextAddress = parseNextResolverRecord(cell);\n            if (oneStep) {\n                if (category === DNS_CATEGORY_NEXT_RESOLVER) {\n                    return nextAddress;\n                } else {\n                    return null;\n                }\n            } else {\n                return await dnsResolveImpl(provider, nextAddress.toString(), rawDomainBytes.slice(resultLen / 8), category, false);\n            }\n        }\n    }\n}\n\n/**\n * Verify and convert domain\n * @param domain    {string}\n * @return {Uint8Array}\n */\nconst domainToBytes = (domain) => {\n    if (!domain || !domain.length) {\n        throw new Error('empty domain');\n    }\n    if (domain === '.') {\n        return new Uint8Array([0]);\n    }\n\n    domain = domain.toLowerCase();\n\n    for (let i = 0; i < domain.length; i++) {\n        if (domain.charCodeAt(i) <= 32) {\n            throw new Error('bytes in range 0..32 are not allowed in domain names');\n        }\n    }\n\n    for (let i = 0; i < domain.length; i++) {\n        const s = domain.substring(i, i + 1);\n        for (let c = 127; c <= 159; c++) { // another control codes range\n            if (s === String.fromCharCode(c)) {\n                throw new Error('bytes in range 127..159 are not allowed in domain names');\n            }\n        }\n    }\n\n    const arr = domain.split('.');\n\n    arr.forEach(part => {\n        if (!part.length) {\n            throw new Error('domain name cannot have an empty component');\n        }\n    });\n\n    const rawDomain = '\\0' + arr.reverse().join('\\0') + '\\0';\n    return new TextEncoder().encode(rawDomain);\n}\n\n/**\n * @param provider  {HttpProvider}\n * @param rootDnsAddress {string} address of root DNS smart contract\n * @param domain    {string} e.g \"sub.alice.ton\"\n * @param category  {string | undefined} category of requested DNS record\n * @param oneStep {boolean | undefined} non-recursive\n * @returns {Promise<Cell | Address | BN | null>}\n */\nconst dnsResolve = async (provider, rootDnsAddress, domain, category, oneStep) => {\n    const rawDomainBytes = domainToBytes(domain);\n\n    return dnsResolveImpl(provider, rootDnsAddress, rawDomainBytes, category, oneStep);\n}\n\nmodule.exports = {\n    DNS_CATEGORY_NEXT_RESOLVER,\n    DNS_CATEGORY_SITE,\n    DNS_CATEGORY_WALLET,\n    categoryToBN,\n    domainToBytes,\n    createSmartContractAddressRecord,\n    createAdnlAddressRecord,\n    createNextResolverRecord,\n    parseNextResolverRecord,\n    parseSmartContractAddressRecord,\n    dnsResolve\n};"],"mappings":"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"},"metadata":{},"sourceType":"script"}