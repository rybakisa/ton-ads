{"ast":null,"code":"const BN = require(\"bn.js\");\n\nconst nacl = require(\"tweetnacl\");\n\nconst ethunit = require(\"ethjs-unit\");\n\nconst isCryptoAvailable = typeof self !== 'undefined' && self.crypto && self.crypto.subtle;\nlet myCrypto = null;\n\nif (isCryptoAvailable) {// web\n  // nothing to do\n} else {\n  // nodejs or react-native\n  myCrypto = require('isomorphic-webcrypto');\n}\n/**\n * @param bytes {Uint8Array}\n * @return  {Promise<ArrayBuffer>}\n */\n\n\nfunction sha256(bytes) {\n  if (isCryptoAvailable) {\n    // web\n    return crypto.subtle.digest(\"SHA-256\", bytes);\n  } else {\n    // nodejs or react-native\n    return myCrypto.subtle.digest({\n      name: \"SHA-256\"\n    }, bytes);\n  }\n}\n/**\n * from coins to nanocoins\n * @param amount {BN | string}\n * @return {BN}\n */\n\n\nfunction toNano(amount) {\n  if (!BN.isBN(amount) && !(typeof amount === 'string')) {\n    throw new Error('Please pass numbers as strings or BN objects to avoid precision errors.');\n  }\n\n  return ethunit.toWei(amount, 'gwei');\n}\n/**\n * from nanocoins to coins\n * @param amount  {BN | string}\n * @return {string}\n */\n\n\nfunction fromNano(amount) {\n  if (!BN.isBN(amount) && !(typeof amount === 'string')) {\n    throw new Error('Please pass numbers as strings or BN objects to avoid precision errors.');\n  }\n\n  return ethunit.fromWei(amount, 'gwei');\n} // look up tables\n\n\nconst to_hex_array = [];\nconst to_byte_map = {};\n\nfor (let ord = 0; ord <= 0xff; ord++) {\n  let s = ord.toString(16);\n\n  if (s.length < 2) {\n    s = \"0\" + s;\n  }\n\n  to_hex_array.push(s);\n  to_byte_map[s] = ord;\n} //  converter using lookups\n\n/**\n * @param buffer  {Uint8Array}\n * @return {string}\n */\n\n\nfunction bytesToHex(buffer) {\n  const hex_array = []; //(new Uint8Array(buffer)).forEach((v) => { hex_array.push(to_hex_array[v]) });\n\n  for (let i = 0; i < buffer.byteLength; i++) {\n    hex_array.push(to_hex_array[buffer[i]]);\n  }\n\n  return hex_array.join(\"\");\n} // reverse conversion using lookups\n\n/**\n * @param s {string}\n * @return {Uint8Array}\n */\n\n\nfunction hexToBytes(s) {\n  s = s.toLowerCase();\n  const length2 = s.length;\n\n  if (length2 % 2 !== 0) {\n    throw \"hex string must have length a multiple of 2\";\n  }\n\n  const length = length2 / 2;\n  const result = new Uint8Array(length);\n\n  for (let i = 0; i < length; i++) {\n    const i2 = i * 2;\n    const b = s.substring(i2, i2 + 2);\n    if (!to_byte_map.hasOwnProperty(b)) throw new Error('invalid hex character ' + b);\n    result[i] = to_byte_map[b];\n  }\n\n  return result;\n}\n/**\n * @param str {string}\n * @param size  {number}\n * @return {Uint8Array}\n */\n\n\nfunction stringToBytes(str) {\n  let size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  let buf;\n  let bufView;\n\n  if (size === 1) {\n    buf = new ArrayBuffer(str.length);\n    bufView = new Uint8Array(buf);\n  }\n\n  if (size === 2) {\n    buf = new ArrayBuffer(str.length * 2);\n    bufView = new Uint16Array(buf);\n  }\n\n  if (size === 4) {\n    buf = new ArrayBuffer(str.length * 4);\n    bufView = new Uint32Array(buf);\n  }\n\n  for (let i = 0, strLen = str.length; i < strLen; i++) {\n    bufView[i] = str.charCodeAt(i);\n  }\n\n  return new Uint8Array(bufView.buffer);\n}\n/**\n * @private\n * @param crc {number}\n * @param bytes {Uint8Array}\n * @return {number}\n */\n\n\nfunction _crc32c(crc, bytes) {\n  const POLY = 0x82f63b78;\n  crc ^= 0xffffffff;\n\n  for (let n = 0; n < bytes.length; n++) {\n    crc ^= bytes[n];\n    crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;\n    crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;\n    crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;\n    crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;\n    crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;\n    crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;\n    crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;\n    crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;\n  }\n\n  return crc ^ 0xffffffff;\n}\n/**\n * @param bytes {Uint8Array}\n * @return {Uint8Array}\n */\n\n\nfunction crc32c(bytes) {\n  //Version suitable for crc32-c of BOC\n  const int_crc = _crc32c(0, bytes);\n\n  const arr = new ArrayBuffer(4);\n  const view = new DataView(arr);\n  view.setUint32(0, int_crc, false);\n  return new Uint8Array(arr).reverse();\n}\n/**\n * @param data  {ArrayLike<number>}\n * @return {Uint8Array}\n */\n\n\nfunction crc16(data) {\n  const poly = 0x1021;\n  let reg = 0;\n  const message = new Uint8Array(data.length + 2);\n  message.set(data);\n\n  for (let byte of message) {\n    let mask = 0x80;\n\n    while (mask > 0) {\n      reg <<= 1;\n\n      if (byte & mask) {\n        reg += 1;\n      }\n\n      mask >>= 1;\n\n      if (reg > 0xffff) {\n        reg &= 0xffff;\n        reg ^= poly;\n      }\n    }\n  }\n\n  return new Uint8Array([Math.floor(reg / 256), reg % 256]);\n}\n/**\n * @param a {Uint8Array}\n * @param b {Uint8Array}\n * @return {Uint8Array}\n */\n\n\nfunction concatBytes(a, b) {\n  const c = new Uint8Array(a.length + b.length);\n  c.set(a);\n  c.set(b, a.length);\n  return c;\n}\n/**\n * @param a {Uint8Array}\n * @param b {Uint8Array}\n * @return {boolean}\n */\n\n\nfunction compareBytes(a, b) {\n  // TODO Make it smarter\n  return a.toString() === b.toString();\n}\n\nconst base64abc = (() => {\n  const abc = [];\n  const A = \"A\".charCodeAt(0);\n  const a = \"a\".charCodeAt(0);\n  const n = \"0\".charCodeAt(0);\n\n  for (let i = 0; i < 26; ++i) {\n    abc.push(String.fromCharCode(A + i));\n  }\n\n  for (let i = 0; i < 26; ++i) {\n    abc.push(String.fromCharCode(a + i));\n  }\n\n  for (let i = 0; i < 10; ++i) {\n    abc.push(String.fromCharCode(n + i));\n  }\n\n  abc.push(\"+\");\n  abc.push(\"/\");\n  return abc;\n})();\n/**\n * @param bytes {Uint8Array}\n * @return {string}\n */\n\n\nfunction bytesToBase64(bytes) {\n  let result = \"\";\n  let i;\n  const l = bytes.length;\n\n  for (i = 2; i < l; i += 3) {\n    result += base64abc[bytes[i - 2] >> 2];\n    result += base64abc[(bytes[i - 2] & 0x03) << 4 | bytes[i - 1] >> 4];\n    result += base64abc[(bytes[i - 1] & 0x0f) << 2 | bytes[i] >> 6];\n    result += base64abc[bytes[i] & 0x3f];\n  }\n\n  if (i === l + 1) {\n    // 1 octet missing\n    result += base64abc[bytes[i - 2] >> 2];\n    result += base64abc[(bytes[i - 2] & 0x03) << 4];\n    result += \"==\";\n  }\n\n  if (i === l) {\n    // 2 octets missing\n    result += base64abc[bytes[i - 2] >> 2];\n    result += base64abc[(bytes[i - 2] & 0x03) << 4 | bytes[i - 1] >> 4];\n    result += base64abc[(bytes[i - 1] & 0x0f) << 2];\n    result += \"=\";\n  }\n\n  return result;\n} // todo: base64 decoding process could ignore one extra character at the end of string and the byte-length check below won't be able to catch it.\n\n\nfunction base64toString(base64) {\n  if (typeof self === 'undefined') {\n    return Buffer.from(base64, 'base64').toString('binary'); // todo: (tolya-yanot) Buffer silently ignore incorrect base64 symbols, we need to throw error\n  } else {\n    return atob(base64);\n  }\n}\n\nfunction stringToBase64(s) {\n  if (typeof self === 'undefined') {\n    return Buffer.from(s, 'binary').toString('base64'); // todo: (tolya-yanot) Buffer silently ignore incorrect base64 symbols, we need to throw error\n  } else {\n    return btoa(s);\n  }\n}\n/**\n * @param base64  {string}\n * @return {Uint8Array}\n */\n\n\nfunction base64ToBytes(base64) {\n  const binary_string = base64toString(base64);\n  const len = binary_string.length;\n  const bytes = new Uint8Array(len);\n\n  for (let i = 0; i < len; i++) {\n    bytes[i] = binary_string.charCodeAt(i);\n  }\n\n  return bytes;\n}\n/**\n * @param n  {number}\n * @param ui8array  {Uint8Array}\n * @return {number}\n */\n\n\nfunction readNBytesUIntFromArray(n, ui8array) {\n  let res = 0;\n\n  for (let c = 0; c < n; c++) {\n    res *= 256;\n    res += ui8array[c];\n  }\n\n  return res;\n}\n/**\n * @param seed  {Uint8Array}\n * @returns {nacl.SignKeyPair}\n */\n\n\nfunction keyPairFromSeed(seed) {\n  return nacl.sign.keyPair.fromSeed(seed);\n}\n/**\n * @returns {nacl.SignKeyPair}\n */\n\n\nfunction newKeyPair() {\n  return nacl.sign.keyPair();\n}\n/**\n * @returns {Uint8Array}\n */\n\n\nfunction newSeed() {\n  return nacl.sign.keyPair().secretKey.slice(0, 32);\n}\n\nmodule.exports = {\n  BN,\n  nacl,\n  sha256,\n  fromNano,\n  toNano,\n  bytesToHex,\n  hexToBytes,\n  stringToBytes,\n  crc32c,\n  crc16,\n  concatBytes,\n  bytesToBase64,\n  base64ToBytes,\n  base64toString,\n  stringToBase64,\n  compareBytes,\n  readNBytesUIntFromArray,\n  keyPairFromSeed,\n  newKeyPair,\n  newSeed\n};","map":{"version":3,"names":["BN","require","nacl","ethunit","isCryptoAvailable","self","crypto","subtle","myCrypto","sha256","bytes","digest","name","toNano","amount","isBN","Error","toWei","fromNano","fromWei","to_hex_array","to_byte_map","ord","s","toString","length","push","bytesToHex","buffer","hex_array","i","byteLength","join","hexToBytes","toLowerCase","length2","result","Uint8Array","i2","b","substring","hasOwnProperty","stringToBytes","str","size","buf","bufView","ArrayBuffer","Uint16Array","Uint32Array","strLen","charCodeAt","_crc32c","crc","POLY","n","crc32c","int_crc","arr","view","DataView","setUint32","reverse","crc16","data","poly","reg","message","set","byte","mask","Math","floor","concatBytes","a","c","compareBytes","base64abc","abc","A","String","fromCharCode","bytesToBase64","l","base64toString","base64","Buffer","from","atob","stringToBase64","btoa","base64ToBytes","binary_string","len","readNBytesUIntFromArray","ui8array","res","keyPairFromSeed","seed","sign","keyPair","fromSeed","newKeyPair","newSeed","secretKey","slice","module","exports"],"sources":["/home/rybakisa/Desktop/TEMP/HackaTON/TON Ads/ton-ads/node_modules/tonweb/src/utils/Utils.js"],"sourcesContent":["const BN = require(\"bn.js\");\nconst nacl = require(\"tweetnacl\");\nconst ethunit = require(\"ethjs-unit\");\n\nconst isCryptoAvailable = typeof self !== 'undefined' && self.crypto && self.crypto.subtle;\n\nlet myCrypto = null;\n\nif (isCryptoAvailable) { // web\n    // nothing to do\n} else { // nodejs or react-native\n    myCrypto = require('isomorphic-webcrypto');\n}\n\n/**\n * @param bytes {Uint8Array}\n * @return  {Promise<ArrayBuffer>}\n */\nfunction sha256(bytes) {\n    if (isCryptoAvailable) { // web\n        return crypto.subtle.digest(\"SHA-256\", bytes);\n    } else {  // nodejs or react-native\n        return myCrypto.subtle.digest({name:\"SHA-256\"}, bytes);\n    }\n}\n\n/**\n * from coins to nanocoins\n * @param amount {BN | string}\n * @return {BN}\n */\nfunction toNano(amount) {\n    if (!BN.isBN(amount) && !(typeof amount === 'string')) {\n        throw new Error('Please pass numbers as strings or BN objects to avoid precision errors.');\n    }\n\n    return ethunit.toWei(amount, 'gwei');\n}\n\n/**\n * from nanocoins to coins\n * @param amount  {BN | string}\n * @return {string}\n */\nfunction fromNano(amount) {\n    if (!BN.isBN(amount) && !(typeof amount === 'string')) {\n        throw new Error('Please pass numbers as strings or BN objects to avoid precision errors.');\n    }\n\n    return ethunit.fromWei(amount, 'gwei');\n}\n\n// look up tables\nconst to_hex_array = [];\nconst to_byte_map = {};\nfor (let ord = 0; ord <= 0xff; ord++) {\n    let s = ord.toString(16);\n    if (s.length < 2) {\n        s = \"0\" + s;\n    }\n    to_hex_array.push(s);\n    to_byte_map[s] = ord;\n}\n\n//  converter using lookups\n/**\n * @param buffer  {Uint8Array}\n * @return {string}\n */\nfunction bytesToHex(buffer) {\n    const hex_array = [];\n    //(new Uint8Array(buffer)).forEach((v) => { hex_array.push(to_hex_array[v]) });\n    for (let i = 0; i < buffer.byteLength; i++) {\n        hex_array.push(to_hex_array[buffer[i]]);\n    }\n    return hex_array.join(\"\");\n}\n\n// reverse conversion using lookups\n/**\n * @param s {string}\n * @return {Uint8Array}\n */\nfunction hexToBytes(s) {\n    s = s.toLowerCase();\n    const length2 = s.length;\n    if (length2 % 2 !== 0) {\n        throw \"hex string must have length a multiple of 2\";\n    }\n    const length = length2 / 2;\n    const result = new Uint8Array(length);\n    for (let i = 0; i < length; i++) {\n        const i2 = i * 2;\n        const b = s.substring(i2, i2 + 2);\n        if (!to_byte_map.hasOwnProperty(b)) throw new Error('invalid hex character ' + b);\n        result[i] = to_byte_map[b];\n    }\n    return result;\n}\n\n/**\n * @param str {string}\n * @param size  {number}\n * @return {Uint8Array}\n */\nfunction stringToBytes(str, size = 1) {\n    let buf;\n    let bufView;\n    if (size === 1) {\n        buf = new ArrayBuffer(str.length);\n        bufView = new Uint8Array(buf);\n    }\n    if (size === 2) {\n        buf = new ArrayBuffer(str.length * 2);\n        bufView = new Uint16Array(buf);\n    }\n    if (size === 4) {\n        buf = new ArrayBuffer(str.length * 4);\n        bufView = new Uint32Array(buf);\n    }\n    for (let i = 0, strLen = str.length; i < strLen; i++) {\n        bufView[i] = str.charCodeAt(i);\n    }\n    return new Uint8Array(bufView.buffer);\n}\n\n\n/**\n * @private\n * @param crc {number}\n * @param bytes {Uint8Array}\n * @return {number}\n */\nfunction _crc32c(crc, bytes) {\n    const POLY = 0x82f63b78;\n\n    crc ^= 0xffffffff;\n    for (let n = 0; n < bytes.length; n++) {\n        crc ^= bytes[n];\n        crc = crc & 1 ? (crc >>> 1) ^ POLY : crc >>> 1;\n        crc = crc & 1 ? (crc >>> 1) ^ POLY : crc >>> 1;\n        crc = crc & 1 ? (crc >>> 1) ^ POLY : crc >>> 1;\n        crc = crc & 1 ? (crc >>> 1) ^ POLY : crc >>> 1;\n        crc = crc & 1 ? (crc >>> 1) ^ POLY : crc >>> 1;\n        crc = crc & 1 ? (crc >>> 1) ^ POLY : crc >>> 1;\n        crc = crc & 1 ? (crc >>> 1) ^ POLY : crc >>> 1;\n        crc = crc & 1 ? (crc >>> 1) ^ POLY : crc >>> 1;\n    }\n    return crc ^ 0xffffffff;\n}\n\n/**\n * @param bytes {Uint8Array}\n * @return {Uint8Array}\n */\nfunction crc32c(bytes) {\n    //Version suitable for crc32-c of BOC\n    const int_crc = _crc32c(0, bytes);\n    const arr = new ArrayBuffer(4);\n    const view = new DataView(arr);\n    view.setUint32(0, int_crc, false);\n    return new Uint8Array(arr).reverse();\n}\n\n/**\n * @param data  {ArrayLike<number>}\n * @return {Uint8Array}\n */\nfunction crc16(data) {\n    const poly = 0x1021;\n    let reg = 0;\n    const message = new Uint8Array(data.length + 2);\n    message.set(data);\n    for (let byte of message) {\n        let mask = 0x80;\n        while (mask > 0) {\n            reg <<= 1;\n            if (byte & mask) {\n                reg += 1;\n            }\n            mask >>= 1\n            if (reg > 0xffff) {\n                reg &= 0xffff;\n                reg ^= poly;\n            }\n        }\n    }\n    return new Uint8Array([Math.floor(reg / 256), reg % 256]);\n}\n\n/**\n * @param a {Uint8Array}\n * @param b {Uint8Array}\n * @return {Uint8Array}\n */\nfunction concatBytes(a, b) {\n    const c = new Uint8Array(a.length + b.length);\n    c.set(a);\n    c.set(b, a.length);\n    return c;\n}\n\n/**\n * @param a {Uint8Array}\n * @param b {Uint8Array}\n * @return {boolean}\n */\nfunction compareBytes(a, b) {\n    // TODO Make it smarter\n    return a.toString() === b.toString();\n}\n\nconst base64abc = (() => {\n    const abc = []\n    const A = \"A\".charCodeAt(0);\n    const a = \"a\".charCodeAt(0);\n    const n = \"0\".charCodeAt(0);\n    for (let i = 0; i < 26; ++i) {\n        abc.push(String.fromCharCode(A + i));\n    }\n    for (let i = 0; i < 26; ++i) {\n        abc.push(String.fromCharCode(a + i));\n    }\n    for (let i = 0; i < 10; ++i) {\n        abc.push(String.fromCharCode(n + i));\n    }\n    abc.push(\"+\");\n    abc.push(\"/\");\n    return abc;\n})();\n\n/**\n * @param bytes {Uint8Array}\n * @return {string}\n */\nfunction bytesToBase64(bytes) {\n    let result = \"\";\n    let i;\n    const l = bytes.length;\n    for (i = 2; i < l; i += 3) {\n        result += base64abc[bytes[i - 2] >> 2];\n        result += base64abc[((bytes[i - 2] & 0x03) << 4) | (bytes[i - 1] >> 4)];\n        result += base64abc[((bytes[i - 1] & 0x0f) << 2) | (bytes[i] >> 6)];\n        result += base64abc[bytes[i] & 0x3f];\n    }\n    if (i === l + 1) {\n        // 1 octet missing\n        result += base64abc[bytes[i - 2] >> 2];\n        result += base64abc[(bytes[i - 2] & 0x03) << 4];\n        result += \"==\";\n    }\n    if (i === l) {\n        // 2 octets missing\n        result += base64abc[bytes[i - 2] >> 2];\n        result += base64abc[((bytes[i - 2] & 0x03) << 4) | (bytes[i - 1] >> 4)];\n        result += base64abc[(bytes[i - 1] & 0x0f) << 2];\n        result += \"=\";\n    }\n    return result;\n}\n\n// todo: base64 decoding process could ignore one extra character at the end of string and the byte-length check below won't be able to catch it.\nfunction base64toString(base64) {\n    if (typeof self === 'undefined') {\n        return Buffer.from(base64, 'base64').toString('binary'); // todo: (tolya-yanot) Buffer silently ignore incorrect base64 symbols, we need to throw error\n    } else {\n        return atob(base64);\n    }\n}\n\nfunction stringToBase64(s) {\n    if (typeof self === 'undefined') {\n        return Buffer.from(s, 'binary').toString('base64'); // todo: (tolya-yanot) Buffer silently ignore incorrect base64 symbols, we need to throw error\n    } else {\n        return btoa(s);\n    }\n}\n\n/**\n * @param base64  {string}\n * @return {Uint8Array}\n */\nfunction base64ToBytes(base64) {\n    const binary_string = base64toString(base64);\n    const len = binary_string.length;\n    const bytes = new Uint8Array(len);\n    for (let i = 0; i < len; i++) {\n        bytes[i] = binary_string.charCodeAt(i);\n    }\n    return bytes;\n}\n\n/**\n * @param n  {number}\n * @param ui8array  {Uint8Array}\n * @return {number}\n */\nfunction readNBytesUIntFromArray(n, ui8array) {\n    let res = 0;\n    for (let c = 0; c < n; c++) {\n        res *= 256;\n        res += ui8array[c];\n    }\n    return res;\n}\n\n/**\n * @param seed  {Uint8Array}\n * @returns {nacl.SignKeyPair}\n */\nfunction keyPairFromSeed(seed) {\n    return nacl.sign.keyPair.fromSeed(seed);\n}\n\n/**\n * @returns {nacl.SignKeyPair}\n */\nfunction newKeyPair() {\n    return nacl.sign.keyPair();\n}\n\n/**\n * @returns {Uint8Array}\n */\nfunction newSeed() {\n    return nacl.sign.keyPair().secretKey.slice(0, 32);\n}\n\nmodule.exports = {\n    BN,\n    nacl,\n    sha256,\n    fromNano,\n    toNano,\n    bytesToHex,\n    hexToBytes,\n    stringToBytes,\n    crc32c,\n    crc16,\n    concatBytes,\n    bytesToBase64,\n    base64ToBytes,\n    base64toString,\n    stringToBase64,\n    compareBytes,\n    readNBytesUIntFromArray,\n    keyPairFromSeed,\n    newKeyPair,\n    newSeed\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}