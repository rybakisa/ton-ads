{"ast":null,"code":"const {\n  Cell\n} = require(\"../boc\");\n\nconst {\n  Address,\n  bytesToBase64,\n  bytesToHex\n} = require(\"../utils\");\n\nclass Contract {\n  /**\n   * @param provider    {HttpProvider}\n   * @param options    {{code?: Cell, address?: Address | string, wc?: number}}\n   */\n  constructor(provider, options) {\n    this.provider = provider;\n    this.options = options;\n    this.address = options.address ? new Address(options.address) : null;\n    if (!options.wc) options.wc = this.address ? this.address.wc : 0;\n    this.methods = {};\n  }\n  /**\n   * @return {Promise<Address>}\n   */\n\n\n  async getAddress() {\n    if (!this.address) {\n      this.address = (await this.createStateInit()).address;\n    }\n\n    return this.address;\n  }\n  /**\n   * @private\n   * @return {Cell} cell contains contact code\n   */\n\n\n  createCodeCell() {\n    if (!this.options.code) throw new Error('Contract: options.code is not defined');\n    return this.options.code;\n  }\n  /**\n   * Method to override\n   * @protected\n   * @return {Cell} cell contains contract data\n   */\n\n\n  createDataCell() {\n    return new Cell();\n  }\n  /**\n   * @protected\n   * @return {Promise<{stateInit: Cell, address: Address, code: Cell, data: Cell}>}\n   */\n\n\n  async createStateInit() {\n    const codeCell = this.createCodeCell();\n    const dataCell = this.createDataCell();\n    const stateInit = Contract.createStateInit(codeCell, dataCell);\n    const stateInitHash = await stateInit.hash();\n    const address = new Address(this.options.wc + \":\" + bytesToHex(stateInitHash));\n    return {\n      stateInit: stateInit,\n      address: address,\n      code: codeCell,\n      data: dataCell\n    };\n  } // _ split_depth:(Maybe (## 5)) special:(Maybe TickTock)\n  // code:(Maybe ^Cell) data:(Maybe ^Cell)\n  // library:(Maybe ^Cell) = StateInit;\n\n  /**\n   * @param code  {Cell}\n   * @param data  {Cell}\n   * @param library {null}\n   * @param splitDepth {null}\n   * @param ticktock  {null}\n   * @return {Cell}\n   */\n\n\n  static createStateInit(code, data) {\n    let library = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let splitDepth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    let ticktock = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    if (library) throw \"Library in state init is not implemented\";\n    if (splitDepth) throw \"Split depth in state init is not implemented\";\n    if (ticktock) throw \"Ticktock in state init is not implemented\";\n    const stateInit = new Cell();\n    stateInit.bits.writeBitArray([Boolean(splitDepth), Boolean(ticktock), Boolean(code), Boolean(data), Boolean(library)]);\n    if (code) stateInit.refs.push(code);\n    if (data) stateInit.refs.push(data);\n    if (library) stateInit.refs.push(library);\n    return stateInit;\n  } // extra_currencies$_ dict:(HashmapE 32 (VarUInteger 32))\n  // = ExtraCurrencyCollection;\n  // currencies$_ grams:Grams other:ExtraCurrencyCollection\n  // = CurrencyCollection;\n  //int_msg_info$0 ihr_disabled:Bool bounce:Bool\n  //src:MsgAddressInt dest:MsgAddressInt\n  //value:CurrencyCollection ihr_fee:Grams fwd_fee:Grams\n  //created_lt:uint64 created_at:uint32 = CommonMsgInfo;\n\n  /**\n   * @param dest  {Address | string}\n   * @param gramValue  {number | BN}\n   * @param ihrDisabled  {boolean}\n   * @param bounce  {null | boolean}\n   * @param bounced {boolean}\n   * @param src  {Address | string}\n   * @param currencyCollection  {null}\n   * @param ihrFees  {number | BN}\n   * @param fwdFees  {number | BN}\n   * @param createdLt  {number | BN}\n   * @param createdAt  {number | BN}\n   * @return {Cell}\n   */\n\n\n  static createInternalMessageHeader(dest) {\n    let gramValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let ihrDisabled = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let bounce = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    let bounced = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    let src = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n    let currencyCollection = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n    let ihrFees = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;\n    let fwdFees = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;\n    let createdLt = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;\n    let createdAt = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 0;\n    const message = new Cell();\n    message.bits.writeBit(false);\n    message.bits.writeBit(ihrDisabled);\n\n    if (!(bounce === null)) {\n      message.bits.writeBit(bounce);\n    } else {\n      message.bits.writeBit(new Address(dest).isBounceable);\n    }\n\n    message.bits.writeBit(bounced);\n    message.bits.writeAddress(src ? new Address(src) : null);\n    message.bits.writeAddress(new Address(dest));\n    message.bits.writeGrams(gramValue);\n\n    if (currencyCollection) {\n      throw \"Currency collections are not implemented yet\";\n    }\n\n    message.bits.writeBit(Boolean(currencyCollection));\n    message.bits.writeGrams(ihrFees);\n    message.bits.writeGrams(fwdFees);\n    message.bits.writeUint(createdLt, 64);\n    message.bits.writeUint(createdAt, 32);\n    return message;\n  } //ext_in_msg_info$10 src:MsgAddressExt dest:MsgAddressInt\n  //import_fee:Grams = CommonMsgInfo;\n\n  /**\n   * @param dest  {Address | string}\n   * @param src  {Address | string}\n   * @param importFee  {number | BN}\n   * @return {Cell}\n   */\n\n\n  static createExternalMessageHeader(dest) {\n    let src = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let importFee = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    const message = new Cell();\n    message.bits.writeUint(2, 2);\n    message.bits.writeAddress(src ? new Address(src) : null);\n    message.bits.writeAddress(new Address(dest));\n    message.bits.writeGrams(importFee);\n    return message;\n  } //tblkch.pdf, page 57\n\n  /**\n   * Create CommonMsgInfo contains header, stateInit, body\n   * @param header {Cell}\n   * @param stateInit?  {Cell}\n   * @param body?  {Cell}\n   * @return {Cell}\n   */\n\n\n  static createCommonMsgInfo(header) {\n    let stateInit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let body = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    const commonMsgInfo = new Cell();\n    commonMsgInfo.writeCell(header);\n\n    if (stateInit) {\n      commonMsgInfo.bits.writeBit(true); //-1:  need at least one bit for body\n      // TODO we also should check for free refs here\n\n      if (commonMsgInfo.bits.getFreeBits() - 1 >= stateInit.bits.getUsedBits()) {\n        commonMsgInfo.bits.writeBit(false);\n        commonMsgInfo.writeCell(stateInit);\n      } else {\n        commonMsgInfo.bits.writeBit(true);\n        commonMsgInfo.refs.push(stateInit);\n      }\n    } else {\n      commonMsgInfo.bits.writeBit(false);\n    } // TODO we also should check for free refs here\n\n\n    if (body) {\n      if (commonMsgInfo.bits.getFreeBits() >= body.bits.getUsedBits()) {\n        commonMsgInfo.bits.writeBit(false);\n        commonMsgInfo.writeCell(body);\n      } else {\n        commonMsgInfo.bits.writeBit(true);\n        commonMsgInfo.refs.push(body);\n      }\n    } else {\n      commonMsgInfo.bits.writeBit(false);\n    }\n\n    return commonMsgInfo;\n  }\n\n  static createMethod(provider, queryPromise) {\n    return {\n      getQuery: async () => {\n        return (await queryPromise).message;\n      },\n      send: async () => {\n        const query = await queryPromise;\n        const boc = bytesToBase64(await query.message.toBoc(false));\n        return provider.sendBoc(boc);\n      },\n      estimateFee: async () => {\n        const query = await queryPromise;\n        const serialized = query.code ? // deploy\n        {\n          address: query.address.toString(true, true, false),\n          body: bytesToBase64(await query.body.toBoc(false)),\n          init_code: bytesToBase64(await query.code.toBoc(false)),\n          init_data: bytesToBase64(await query.data.toBoc(false))\n        } : {\n          address: query.address.toString(true, true, true),\n          body: bytesToBase64(await query.body.toBoc(false))\n        };\n        return provider.getEstimateFee(serialized);\n      }\n    };\n  }\n\n}\n\nmodule.exports = {\n  Contract\n};","map":{"version":3,"names":["Cell","require","Address","bytesToBase64","bytesToHex","Contract","constructor","provider","options","address","wc","methods","getAddress","createStateInit","createCodeCell","code","Error","createDataCell","codeCell","dataCell","stateInit","stateInitHash","hash","data","library","splitDepth","ticktock","bits","writeBitArray","Boolean","refs","push","createInternalMessageHeader","dest","gramValue","ihrDisabled","bounce","bounced","src","currencyCollection","ihrFees","fwdFees","createdLt","createdAt","message","writeBit","isBounceable","writeAddress","writeGrams","writeUint","createExternalMessageHeader","importFee","createCommonMsgInfo","header","body","commonMsgInfo","writeCell","getFreeBits","getUsedBits","createMethod","queryPromise","getQuery","send","query","boc","toBoc","sendBoc","estimateFee","serialized","toString","init_code","init_data","getEstimateFee","module","exports"],"sources":["/home/rybakisa/Desktop/TEMP/HackaTON/TON Ads/ton-ads/node_modules/tonweb/src/contract/index.js"],"sourcesContent":["const {Cell} = require(\"../boc\");\nconst {Address, bytesToBase64, bytesToHex} = require(\"../utils\");\n\nclass Contract {\n    /**\n     * @param provider    {HttpProvider}\n     * @param options    {{code?: Cell, address?: Address | string, wc?: number}}\n     */\n    constructor(provider, options) {\n        this.provider = provider;\n        this.options = options;\n        this.address = options.address ? new Address(options.address) : null;\n        if (!options.wc) options.wc = this.address ? this.address.wc : 0;\n        this.methods = {};\n    }\n\n    /**\n     * @return {Promise<Address>}\n     */\n    async getAddress() {\n        if (!this.address) {\n            this.address = (await this.createStateInit()).address;\n        }\n        return this.address;\n    }\n\n    /**\n     * @private\n     * @return {Cell} cell contains contact code\n     */\n    createCodeCell() {\n        if (!this.options.code) throw new Error('Contract: options.code is not defined')\n        return this.options.code;\n    }\n\n    /**\n     * Method to override\n     * @protected\n     * @return {Cell} cell contains contract data\n     */\n    createDataCell() {\n        return new Cell();\n    }\n\n    /**\n     * @protected\n     * @return {Promise<{stateInit: Cell, address: Address, code: Cell, data: Cell}>}\n     */\n    async createStateInit() {\n        const codeCell = this.createCodeCell();\n        const dataCell = this.createDataCell();\n        const stateInit = Contract.createStateInit(codeCell, dataCell);\n        const stateInitHash = await stateInit.hash();\n        const address = new Address(this.options.wc + \":\" + bytesToHex(stateInitHash));\n        return {\n            stateInit: stateInit,\n            address: address,\n            code: codeCell,\n            data: dataCell,\n        }\n    }\n\n    // _ split_depth:(Maybe (## 5)) special:(Maybe TickTock)\n    // code:(Maybe ^Cell) data:(Maybe ^Cell)\n    // library:(Maybe ^Cell) = StateInit;\n    /**\n     * @param code  {Cell}\n     * @param data  {Cell}\n     * @param library {null}\n     * @param splitDepth {null}\n     * @param ticktock  {null}\n     * @return {Cell}\n     */\n    static createStateInit(code,\n                           data,\n                           library = null,\n                           splitDepth = null,\n                           ticktock = null) {\n        if (library)\n            throw \"Library in state init is not implemented\";\n        if (splitDepth)\n            throw \"Split depth in state init is not implemented\";\n        if (ticktock)\n            throw \"Ticktock in state init is not implemented\";\n\n        const stateInit = new Cell();\n\n        stateInit.bits.writeBitArray([Boolean(splitDepth), Boolean(ticktock), Boolean(code), Boolean(data), Boolean(library)]);\n        if (code)\n            stateInit.refs.push(code);\n        if (data)\n            stateInit.refs.push(data);\n        if (library)\n            stateInit.refs.push(library);\n        return stateInit;\n    }\n\n    // extra_currencies$_ dict:(HashmapE 32 (VarUInteger 32))\n    // = ExtraCurrencyCollection;\n    // currencies$_ grams:Grams other:ExtraCurrencyCollection\n    // = CurrencyCollection;\n\n    //int_msg_info$0 ihr_disabled:Bool bounce:Bool\n    //src:MsgAddressInt dest:MsgAddressInt\n    //value:CurrencyCollection ihr_fee:Grams fwd_fee:Grams\n    //created_lt:uint64 created_at:uint32 = CommonMsgInfo;\n    /**\n     * @param dest  {Address | string}\n     * @param gramValue  {number | BN}\n     * @param ihrDisabled  {boolean}\n     * @param bounce  {null | boolean}\n     * @param bounced {boolean}\n     * @param src  {Address | string}\n     * @param currencyCollection  {null}\n     * @param ihrFees  {number | BN}\n     * @param fwdFees  {number | BN}\n     * @param createdLt  {number | BN}\n     * @param createdAt  {number | BN}\n     * @return {Cell}\n     */\n    static createInternalMessageHeader(dest,\n                                       gramValue = 0,\n                                       ihrDisabled = true,\n                                       bounce = null,\n                                       bounced = false,\n                                       src = null,\n                                       currencyCollection = null,\n                                       ihrFees = 0,\n                                       fwdFees = 0,\n                                       createdLt = 0,\n                                       createdAt = 0) {\n        const message = new Cell();\n        message.bits.writeBit(false);\n        message.bits.writeBit(ihrDisabled);\n        if (!(bounce === null)) {\n            message.bits.writeBit(bounce);\n        } else {\n            message.bits.writeBit((new Address(dest)).isBounceable);\n        }\n        message.bits.writeBit(bounced);\n        message.bits.writeAddress(src ? new Address(src) : null);\n        message.bits.writeAddress(new Address(dest));\n        message.bits.writeGrams(gramValue);\n        if (currencyCollection) {\n            throw \"Currency collections are not implemented yet\";\n        }\n        message.bits.writeBit(Boolean(currencyCollection));\n        message.bits.writeGrams(ihrFees);\n        message.bits.writeGrams(fwdFees);\n        message.bits.writeUint(createdLt, 64);\n        message.bits.writeUint(createdAt, 32);\n        return message;\n    }\n\n    //ext_in_msg_info$10 src:MsgAddressExt dest:MsgAddressInt\n    //import_fee:Grams = CommonMsgInfo;\n    /**\n     * @param dest  {Address | string}\n     * @param src  {Address | string}\n     * @param importFee  {number | BN}\n     * @return {Cell}\n     */\n    static createExternalMessageHeader(dest,\n                                       src = null,\n                                       importFee = 0) {\n        const message = new Cell();\n        message.bits.writeUint(2, 2);\n        message.bits.writeAddress(src ? new Address(src) : null);\n        message.bits.writeAddress(new Address(dest));\n        message.bits.writeGrams(importFee);\n        return message;\n    }\n\n    //tblkch.pdf, page 57\n    /**\n     * Create CommonMsgInfo contains header, stateInit, body\n     * @param header {Cell}\n     * @param stateInit?  {Cell}\n     * @param body?  {Cell}\n     * @return {Cell}\n     */\n    static createCommonMsgInfo(header, stateInit = null, body = null) {\n        const commonMsgInfo = new Cell();\n        commonMsgInfo.writeCell(header);\n\n        if (stateInit) {\n            commonMsgInfo.bits.writeBit(true);\n            //-1:  need at least one bit for body\n            // TODO we also should check for free refs here\n            if (commonMsgInfo.bits.getFreeBits() - 1 >= stateInit.bits.getUsedBits()) {\n                commonMsgInfo.bits.writeBit(false);\n                commonMsgInfo.writeCell(stateInit);\n            } else {\n                commonMsgInfo.bits.writeBit(true);\n                commonMsgInfo.refs.push(stateInit);\n            }\n        } else {\n            commonMsgInfo.bits.writeBit(false);\n        }\n        // TODO we also should check for free refs here\n        if (body) {\n            if (commonMsgInfo.bits.getFreeBits() >= body.bits.getUsedBits()) {\n                commonMsgInfo.bits.writeBit(false);\n                commonMsgInfo.writeCell(body);\n            } else {\n                commonMsgInfo.bits.writeBit(true);\n                commonMsgInfo.refs.push(body);\n            }\n        } else {\n            commonMsgInfo.bits.writeBit(false);\n        }\n        return commonMsgInfo;\n    }\n\n    static createMethod(provider, queryPromise) {\n        return {\n            getQuery: async () => {\n                return (await queryPromise).message;\n            },\n            send: async () => {\n                const query = await queryPromise;\n                const boc = bytesToBase64(await query.message.toBoc(false));\n                return provider.sendBoc(boc);\n            },\n            estimateFee: async () => {\n                const query = await queryPromise;\n                const serialized = query.code ? // deploy\n                    {\n                        address: query.address.toString(true, true, false),\n                        body: bytesToBase64(await query.body.toBoc(false)),\n                        init_code: bytesToBase64(await query.code.toBoc(false)),\n                        init_data: bytesToBase64(await query.data.toBoc(false)),\n                    } : {\n                        address: query.address.toString(true, true, true),\n                        body: bytesToBase64(await query.body.toBoc(false)),\n                    };\n\n                return provider.getEstimateFee(serialized);\n            }\n        }\n    }\n}\n\nmodule.exports = {Contract};\n"],"mappings":"AAAA,MAAM;EAACA;AAAD,IAASC,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAM;EAACC,OAAD;EAAUC,aAAV;EAAyBC;AAAzB,IAAuCH,OAAO,CAAC,UAAD,CAApD;;AAEA,MAAMI,QAAN,CAAe;EACX;AACJ;AACA;AACA;EACIC,WAAW,CAACC,QAAD,EAAWC,OAAX,EAAoB;IAC3B,KAAKD,QAAL,GAAgBA,QAAhB;IACA,KAAKC,OAAL,GAAeA,OAAf;IACA,KAAKC,OAAL,GAAeD,OAAO,CAACC,OAAR,GAAkB,IAAIP,OAAJ,CAAYM,OAAO,CAACC,OAApB,CAAlB,GAAiD,IAAhE;IACA,IAAI,CAACD,OAAO,CAACE,EAAb,EAAiBF,OAAO,CAACE,EAAR,GAAa,KAAKD,OAAL,GAAe,KAAKA,OAAL,CAAaC,EAA5B,GAAiC,CAA9C;IACjB,KAAKC,OAAL,GAAe,EAAf;EACH;EAED;AACJ;AACA;;;EACoB,MAAVC,UAAU,GAAG;IACf,IAAI,CAAC,KAAKH,OAAV,EAAmB;MACf,KAAKA,OAAL,GAAe,CAAC,MAAM,KAAKI,eAAL,EAAP,EAA+BJ,OAA9C;IACH;;IACD,OAAO,KAAKA,OAAZ;EACH;EAED;AACJ;AACA;AACA;;;EACIK,cAAc,GAAG;IACb,IAAI,CAAC,KAAKN,OAAL,CAAaO,IAAlB,EAAwB,MAAM,IAAIC,KAAJ,CAAU,uCAAV,CAAN;IACxB,OAAO,KAAKR,OAAL,CAAaO,IAApB;EACH;EAED;AACJ;AACA;AACA;AACA;;;EACIE,cAAc,GAAG;IACb,OAAO,IAAIjB,IAAJ,EAAP;EACH;EAED;AACJ;AACA;AACA;;;EACyB,MAAfa,eAAe,GAAG;IACpB,MAAMK,QAAQ,GAAG,KAAKJ,cAAL,EAAjB;IACA,MAAMK,QAAQ,GAAG,KAAKF,cAAL,EAAjB;IACA,MAAMG,SAAS,GAAGf,QAAQ,CAACQ,eAAT,CAAyBK,QAAzB,EAAmCC,QAAnC,CAAlB;IACA,MAAME,aAAa,GAAG,MAAMD,SAAS,CAACE,IAAV,EAA5B;IACA,MAAMb,OAAO,GAAG,IAAIP,OAAJ,CAAY,KAAKM,OAAL,CAAaE,EAAb,GAAkB,GAAlB,GAAwBN,UAAU,CAACiB,aAAD,CAA9C,CAAhB;IACA,OAAO;MACHD,SAAS,EAAEA,SADR;MAEHX,OAAO,EAAEA,OAFN;MAGHM,IAAI,EAAEG,QAHH;MAIHK,IAAI,EAAEJ;IAJH,CAAP;EAMH,CAzDU,CA2DX;EACA;EACA;;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;EAC0B,OAAfN,eAAe,CAACE,IAAD,EACCQ,IADD,EAIkB;IAAA,IAFjBC,OAEiB,uEAFP,IAEO;IAAA,IADjBC,UACiB,uEADJ,IACI;IAAA,IAAjBC,QAAiB,uEAAN,IAAM;IACpC,IAAIF,OAAJ,EACI,MAAM,0CAAN;IACJ,IAAIC,UAAJ,EACI,MAAM,8CAAN;IACJ,IAAIC,QAAJ,EACI,MAAM,2CAAN;IAEJ,MAAMN,SAAS,GAAG,IAAIpB,IAAJ,EAAlB;IAEAoB,SAAS,CAACO,IAAV,CAAeC,aAAf,CAA6B,CAACC,OAAO,CAACJ,UAAD,CAAR,EAAsBI,OAAO,CAACH,QAAD,CAA7B,EAAyCG,OAAO,CAACd,IAAD,CAAhD,EAAwDc,OAAO,CAACN,IAAD,CAA/D,EAAuEM,OAAO,CAACL,OAAD,CAA9E,CAA7B;IACA,IAAIT,IAAJ,EACIK,SAAS,CAACU,IAAV,CAAeC,IAAf,CAAoBhB,IAApB;IACJ,IAAIQ,IAAJ,EACIH,SAAS,CAACU,IAAV,CAAeC,IAAf,CAAoBR,IAApB;IACJ,IAAIC,OAAJ,EACIJ,SAAS,CAACU,IAAV,CAAeC,IAAf,CAAoBP,OAApB;IACJ,OAAOJ,SAAP;EACH,CA5FU,CA8FX;EACA;EACA;EACA;EAEA;EACA;EACA;EACA;;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACsC,OAA3BY,2BAA2B,CAACC,IAAD,EAUgB;IAAA,IATfC,SASe,uEATH,CASG;IAAA,IARfC,WAQe,uEARD,IAQC;IAAA,IAPfC,MAOe,uEAPN,IAOM;IAAA,IANfC,OAMe,uEANL,KAMK;IAAA,IALfC,GAKe,uEALT,IAKS;IAAA,IAJfC,kBAIe,uEAJM,IAIN;IAAA,IAHfC,OAGe,uEAHL,CAGK;IAAA,IAFfC,OAEe,uEAFL,CAEK;IAAA,IADfC,SACe,uEADH,CACG;IAAA,IAAfC,SAAe,0EAAH,CAAG;IAC9C,MAAMC,OAAO,GAAG,IAAI5C,IAAJ,EAAhB;IACA4C,OAAO,CAACjB,IAAR,CAAakB,QAAb,CAAsB,KAAtB;IACAD,OAAO,CAACjB,IAAR,CAAakB,QAAb,CAAsBV,WAAtB;;IACA,IAAI,EAAEC,MAAM,KAAK,IAAb,CAAJ,EAAwB;MACpBQ,OAAO,CAACjB,IAAR,CAAakB,QAAb,CAAsBT,MAAtB;IACH,CAFD,MAEO;MACHQ,OAAO,CAACjB,IAAR,CAAakB,QAAb,CAAuB,IAAI3C,OAAJ,CAAY+B,IAAZ,CAAD,CAAoBa,YAA1C;IACH;;IACDF,OAAO,CAACjB,IAAR,CAAakB,QAAb,CAAsBR,OAAtB;IACAO,OAAO,CAACjB,IAAR,CAAaoB,YAAb,CAA0BT,GAAG,GAAG,IAAIpC,OAAJ,CAAYoC,GAAZ,CAAH,GAAsB,IAAnD;IACAM,OAAO,CAACjB,IAAR,CAAaoB,YAAb,CAA0B,IAAI7C,OAAJ,CAAY+B,IAAZ,CAA1B;IACAW,OAAO,CAACjB,IAAR,CAAaqB,UAAb,CAAwBd,SAAxB;;IACA,IAAIK,kBAAJ,EAAwB;MACpB,MAAM,8CAAN;IACH;;IACDK,OAAO,CAACjB,IAAR,CAAakB,QAAb,CAAsBhB,OAAO,CAACU,kBAAD,CAA7B;IACAK,OAAO,CAACjB,IAAR,CAAaqB,UAAb,CAAwBR,OAAxB;IACAI,OAAO,CAACjB,IAAR,CAAaqB,UAAb,CAAwBP,OAAxB;IACAG,OAAO,CAACjB,IAAR,CAAasB,SAAb,CAAuBP,SAAvB,EAAkC,EAAlC;IACAE,OAAO,CAACjB,IAAR,CAAasB,SAAb,CAAuBN,SAAvB,EAAkC,EAAlC;IACA,OAAOC,OAAP;EACH,CArJU,CAuJX;EACA;;EACA;AACJ;AACA;AACA;AACA;AACA;;;EACsC,OAA3BM,2BAA2B,CAACjB,IAAD,EAEgB;IAAA,IADfK,GACe,uEADT,IACS;IAAA,IAAfa,SAAe,uEAAH,CAAG;IAC9C,MAAMP,OAAO,GAAG,IAAI5C,IAAJ,EAAhB;IACA4C,OAAO,CAACjB,IAAR,CAAasB,SAAb,CAAuB,CAAvB,EAA0B,CAA1B;IACAL,OAAO,CAACjB,IAAR,CAAaoB,YAAb,CAA0BT,GAAG,GAAG,IAAIpC,OAAJ,CAAYoC,GAAZ,CAAH,GAAsB,IAAnD;IACAM,OAAO,CAACjB,IAAR,CAAaoB,YAAb,CAA0B,IAAI7C,OAAJ,CAAY+B,IAAZ,CAA1B;IACAW,OAAO,CAACjB,IAAR,CAAaqB,UAAb,CAAwBG,SAAxB;IACA,OAAOP,OAAP;EACH,CAxKU,CA0KX;;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;;;EAC8B,OAAnBQ,mBAAmB,CAACC,MAAD,EAAwC;IAAA,IAA/BjC,SAA+B,uEAAnB,IAAmB;IAAA,IAAbkC,IAAa,uEAAN,IAAM;IAC9D,MAAMC,aAAa,GAAG,IAAIvD,IAAJ,EAAtB;IACAuD,aAAa,CAACC,SAAd,CAAwBH,MAAxB;;IAEA,IAAIjC,SAAJ,EAAe;MACXmC,aAAa,CAAC5B,IAAd,CAAmBkB,QAAnB,CAA4B,IAA5B,EADW,CAEX;MACA;;MACA,IAAIU,aAAa,CAAC5B,IAAd,CAAmB8B,WAAnB,KAAmC,CAAnC,IAAwCrC,SAAS,CAACO,IAAV,CAAe+B,WAAf,EAA5C,EAA0E;QACtEH,aAAa,CAAC5B,IAAd,CAAmBkB,QAAnB,CAA4B,KAA5B;QACAU,aAAa,CAACC,SAAd,CAAwBpC,SAAxB;MACH,CAHD,MAGO;QACHmC,aAAa,CAAC5B,IAAd,CAAmBkB,QAAnB,CAA4B,IAA5B;QACAU,aAAa,CAACzB,IAAd,CAAmBC,IAAnB,CAAwBX,SAAxB;MACH;IACJ,CAXD,MAWO;MACHmC,aAAa,CAAC5B,IAAd,CAAmBkB,QAAnB,CAA4B,KAA5B;IACH,CAjB6D,CAkB9D;;;IACA,IAAIS,IAAJ,EAAU;MACN,IAAIC,aAAa,CAAC5B,IAAd,CAAmB8B,WAAnB,MAAoCH,IAAI,CAAC3B,IAAL,CAAU+B,WAAV,EAAxC,EAAiE;QAC7DH,aAAa,CAAC5B,IAAd,CAAmBkB,QAAnB,CAA4B,KAA5B;QACAU,aAAa,CAACC,SAAd,CAAwBF,IAAxB;MACH,CAHD,MAGO;QACHC,aAAa,CAAC5B,IAAd,CAAmBkB,QAAnB,CAA4B,IAA5B;QACAU,aAAa,CAACzB,IAAd,CAAmBC,IAAnB,CAAwBuB,IAAxB;MACH;IACJ,CARD,MAQO;MACHC,aAAa,CAAC5B,IAAd,CAAmBkB,QAAnB,CAA4B,KAA5B;IACH;;IACD,OAAOU,aAAP;EACH;;EAEkB,OAAZI,YAAY,CAACpD,QAAD,EAAWqD,YAAX,EAAyB;IACxC,OAAO;MACHC,QAAQ,EAAE,YAAY;QAClB,OAAO,CAAC,MAAMD,YAAP,EAAqBhB,OAA5B;MACH,CAHE;MAIHkB,IAAI,EAAE,YAAY;QACd,MAAMC,KAAK,GAAG,MAAMH,YAApB;QACA,MAAMI,GAAG,GAAG7D,aAAa,CAAC,MAAM4D,KAAK,CAACnB,OAAN,CAAcqB,KAAd,CAAoB,KAApB,CAAP,CAAzB;QACA,OAAO1D,QAAQ,CAAC2D,OAAT,CAAiBF,GAAjB,CAAP;MACH,CARE;MASHG,WAAW,EAAE,YAAY;QACrB,MAAMJ,KAAK,GAAG,MAAMH,YAApB;QACA,MAAMQ,UAAU,GAAGL,KAAK,CAAChD,IAAN,GAAa;QAC5B;UACIN,OAAO,EAAEsD,KAAK,CAACtD,OAAN,CAAc4D,QAAd,CAAuB,IAAvB,EAA6B,IAA7B,EAAmC,KAAnC,CADb;UAEIf,IAAI,EAAEnD,aAAa,CAAC,MAAM4D,KAAK,CAACT,IAAN,CAAWW,KAAX,CAAiB,KAAjB,CAAP,CAFvB;UAGIK,SAAS,EAAEnE,aAAa,CAAC,MAAM4D,KAAK,CAAChD,IAAN,CAAWkD,KAAX,CAAiB,KAAjB,CAAP,CAH5B;UAIIM,SAAS,EAAEpE,aAAa,CAAC,MAAM4D,KAAK,CAACxC,IAAN,CAAW0C,KAAX,CAAiB,KAAjB,CAAP;QAJ5B,CADe,GAMX;UACAxD,OAAO,EAAEsD,KAAK,CAACtD,OAAN,CAAc4D,QAAd,CAAuB,IAAvB,EAA6B,IAA7B,EAAmC,IAAnC,CADT;UAEAf,IAAI,EAAEnD,aAAa,CAAC,MAAM4D,KAAK,CAACT,IAAN,CAAWW,KAAX,CAAiB,KAAjB,CAAP;QAFnB,CANR;QAWA,OAAO1D,QAAQ,CAACiE,cAAT,CAAwBJ,UAAxB,CAAP;MACH;IAvBE,CAAP;EAyBH;;AA7OU;;AAgPfK,MAAM,CAACC,OAAP,GAAiB;EAACrE;AAAD,CAAjB"},"metadata":{},"sourceType":"script"}