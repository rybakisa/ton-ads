{"ast":null,"code":"/** PURE_IMPORTS_START tslib,_Subject,_Observable,_Subscriber,_Subscription,_operators_refCount PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { SubjectSubscriber } from '../Subject';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { refCount as higherOrderRefCount } from '../operators/refCount';\n\nvar ConnectableObservable = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(ConnectableObservable, _super);\n\n  function ConnectableObservable(source, subjectFactory) {\n    var _this = _super.call(this) || this;\n\n    _this.source = source;\n    _this.subjectFactory = subjectFactory;\n    _this._refCount = 0;\n    _this._isComplete = false;\n    return _this;\n  }\n\n  ConnectableObservable.prototype._subscribe = function (subscriber) {\n    return this.getSubject().subscribe(subscriber);\n  };\n\n  ConnectableObservable.prototype.getSubject = function () {\n    var subject = this._subject;\n\n    if (!subject || subject.isStopped) {\n      this._subject = this.subjectFactory();\n    }\n\n    return this._subject;\n  };\n\n  ConnectableObservable.prototype.connect = function () {\n    var connection = this._connection;\n\n    if (!connection) {\n      this._isComplete = false;\n      connection = this._connection = new Subscription();\n      connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this)));\n\n      if (connection.closed) {\n        this._connection = null;\n        connection = Subscription.EMPTY;\n      }\n    }\n\n    return connection;\n  };\n\n  ConnectableObservable.prototype.refCount = function () {\n    return higherOrderRefCount()(this);\n  };\n\n  return ConnectableObservable;\n}(Observable);\n\nexport { ConnectableObservable };\nexport var connectableObservableDescriptor = /*@__PURE__*/function () {\n  var connectableProto = ConnectableObservable.prototype;\n  return {\n    operator: {\n      value: null\n    },\n    _refCount: {\n      value: 0,\n      writable: true\n    },\n    _subject: {\n      value: null,\n      writable: true\n    },\n    _connection: {\n      value: null,\n      writable: true\n    },\n    _subscribe: {\n      value: connectableProto._subscribe\n    },\n    _isComplete: {\n      value: connectableProto._isComplete,\n      writable: true\n    },\n    getSubject: {\n      value: connectableProto.getSubject\n    },\n    connect: {\n      value: connectableProto.connect\n    },\n    refCount: {\n      value: connectableProto.refCount\n    }\n  };\n}();\n\nvar ConnectableSubscriber = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(ConnectableSubscriber, _super);\n\n  function ConnectableSubscriber(destination, connectable) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.connectable = connectable;\n    return _this;\n  }\n\n  ConnectableSubscriber.prototype._error = function (err) {\n    this._unsubscribe();\n\n    _super.prototype._error.call(this, err);\n  };\n\n  ConnectableSubscriber.prototype._complete = function () {\n    this.connectable._isComplete = true;\n\n    this._unsubscribe();\n\n    _super.prototype._complete.call(this);\n  };\n\n  ConnectableSubscriber.prototype._unsubscribe = function () {\n    var connectable = this.connectable;\n\n    if (connectable) {\n      this.connectable = null;\n      var connection = connectable._connection;\n      connectable._refCount = 0;\n      connectable._subject = null;\n      connectable._connection = null;\n\n      if (connection) {\n        connection.unsubscribe();\n      }\n    }\n  };\n\n  return ConnectableSubscriber;\n}(SubjectSubscriber);\n\nvar RefCountOperator = /*@__PURE__*/function () {\n  function RefCountOperator(connectable) {\n    this.connectable = connectable;\n  }\n\n  RefCountOperator.prototype.call = function (subscriber, source) {\n    var connectable = this.connectable;\n    connectable._refCount++;\n    var refCounter = new RefCountSubscriber(subscriber, connectable);\n    var subscription = source.subscribe(refCounter);\n\n    if (!refCounter.closed) {\n      refCounter.connection = connectable.connect();\n    }\n\n    return subscription;\n  };\n\n  return RefCountOperator;\n}();\n\nvar RefCountSubscriber = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(RefCountSubscriber, _super);\n\n  function RefCountSubscriber(destination, connectable) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.connectable = connectable;\n    return _this;\n  }\n\n  RefCountSubscriber.prototype._unsubscribe = function () {\n    var connectable = this.connectable;\n\n    if (!connectable) {\n      this.connection = null;\n      return;\n    }\n\n    this.connectable = null;\n    var refCount = connectable._refCount;\n\n    if (refCount <= 0) {\n      this.connection = null;\n      return;\n    }\n\n    connectable._refCount = refCount - 1;\n\n    if (refCount > 1) {\n      this.connection = null;\n      return;\n    }\n\n    var connection = this.connection;\n    var sharedConnection = connectable._connection;\n    this.connection = null;\n\n    if (sharedConnection && (!connection || sharedConnection === connection)) {\n      sharedConnection.unsubscribe();\n    }\n  };\n\n  return RefCountSubscriber;\n}(Subscriber);","map":{"version":3,"mappings":"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","names":["tslib_1","SubjectSubscriber","Observable","Subscriber","Subscription","ConnectableObservable","_super","source","subjectFactory","_this","_subscribe","subscriber","prototype","getSubject","subject","_subject","isStopped","connect","connection","_connection","subscribe","refCount","connectableObservableDescriptor","operator","value","_refCount","writable","connectableProto","_isComplete","ConnectableSubscriber","destination","connectable","_error","_complete","_unsubscribe","RefCountOperator","refCounter","RefCountSubscriber","subscription","sharedConnection"],"sources":["/home/rybakisa/Desktop/TEMP/HackaTON/TON Ads/ton-ads/node_modules/rxjs/src/internal/observable/ConnectableObservable.ts"],"sourcesContent":["import { Subject, SubjectSubscriber } from '../Subject';\nimport { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { TeardownLogic } from '../types';\nimport { refCount as higherOrderRefCount } from '../operators/refCount';\n\n/**\n * @class ConnectableObservable<T>\n */\nexport class ConnectableObservable<T> extends Observable<T> {\n\n  protected _subject: Subject<T>;\n  protected _refCount: number = 0;\n  protected _connection: Subscription;\n  /** @internal */\n  _isComplete = false;\n\n  constructor(public source: Observable<T>,\n              protected subjectFactory: () => Subject<T>) {\n    super();\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<T>) {\n    return this.getSubject().subscribe(subscriber);\n  }\n\n  protected getSubject(): Subject<T> {\n    const subject = this._subject;\n    if (!subject || subject.isStopped) {\n      this._subject = this.subjectFactory();\n    }\n    return this._subject;\n  }\n\n  connect(): Subscription {\n    let connection = this._connection;\n    if (!connection) {\n      this._isComplete = false;\n      connection = this._connection = new Subscription();\n      connection.add(this.source\n        .subscribe(new ConnectableSubscriber(this.getSubject(), this)));\n      if (connection.closed) {\n        this._connection = null;\n        connection = Subscription.EMPTY;\n      }\n    }\n    return connection;\n  }\n\n  refCount(): Observable<T> {\n    return higherOrderRefCount()(this) as Observable<T>;\n  }\n}\n\nexport const connectableObservableDescriptor: PropertyDescriptorMap = (() => {\n  const connectableProto = <any>ConnectableObservable.prototype;\n  return {\n    operator: { value: null as null },\n    _refCount: { value: 0, writable: true },\n    _subject: { value: null as null, writable: true },\n    _connection: { value: null as null, writable: true },\n    _subscribe: { value: connectableProto._subscribe },\n    _isComplete: { value: connectableProto._isComplete, writable: true },\n    getSubject: { value: connectableProto.getSubject },\n    connect: { value: connectableProto.connect },\n    refCount: { value: connectableProto.refCount }\n  };\n})();\n\nclass ConnectableSubscriber<T> extends SubjectSubscriber<T> {\n  constructor(destination: Subject<T>,\n              private connectable: ConnectableObservable<T>) {\n    super(destination);\n  }\n  protected _error(err: any): void {\n    this._unsubscribe();\n    super._error(err);\n  }\n  protected _complete(): void {\n    this.connectable._isComplete = true;\n    this._unsubscribe();\n    super._complete();\n  }\n  protected _unsubscribe() {\n    const connectable = <any>this.connectable;\n    if (connectable) {\n      this.connectable = null;\n      const connection = connectable._connection;\n      connectable._refCount = 0;\n      connectable._subject = null;\n      connectable._connection = null;\n      if (connection) {\n        connection.unsubscribe();\n      }\n    }\n  }\n}\n\nclass RefCountOperator<T> implements Operator<T, T> {\n  constructor(private connectable: ConnectableObservable<T>) {\n  }\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n\n    const { connectable } = this;\n    (<any> connectable)._refCount++;\n\n    const refCounter = new RefCountSubscriber(subscriber, connectable);\n    const subscription = source.subscribe(refCounter);\n\n    if (!refCounter.closed) {\n      (<any> refCounter).connection = connectable.connect();\n    }\n\n    return subscription;\n  }\n}\n\nclass RefCountSubscriber<T> extends Subscriber<T> {\n\n  private connection: Subscription;\n\n  constructor(destination: Subscriber<T>,\n              private connectable: ConnectableObservable<T>) {\n    super(destination);\n  }\n\n  protected _unsubscribe() {\n\n    const { connectable } = this;\n    if (!connectable) {\n      this.connection = null;\n      return;\n    }\n\n    this.connectable = null;\n    const refCount = (<any> connectable)._refCount;\n    if (refCount <= 0) {\n      this.connection = null;\n      return;\n    }\n\n    (<any> connectable)._refCount = refCount - 1;\n    if (refCount > 1) {\n      this.connection = null;\n      return;\n    }\n\n    ///\n    // Compare the local RefCountSubscriber's connection Subscription to the\n    // connection Subscription on the shared ConnectableObservable. In cases\n    // where the ConnectableObservable source synchronously emits values, and\n    // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n    // execution continues to here before the RefCountOperator has a chance to\n    // supply the RefCountSubscriber with the shared connection Subscription.\n    // For example:\n    // ```\n    // range(0, 10).pipe(\n    //   publish(),\n    //   refCount(),\n    //   take(5),\n    // ).subscribe();\n    // ```\n    // In order to account for this case, RefCountSubscriber should only dispose\n    // the ConnectableObservable's shared connection Subscription if the\n    // connection Subscription exists, *and* either:\n    //   a. RefCountSubscriber doesn't have a reference to the shared connection\n    //      Subscription yet, or,\n    //   b. RefCountSubscriber's connection Subscription reference is identical\n    //      to the shared connection Subscription\n    ///\n    const { connection } = this;\n    const sharedConnection = (<any> connectable)._connection;\n    this.connection = null;\n\n    if (sharedConnection && (!connection || sharedConnection === connection)) {\n      sharedConnection.unsubscribe();\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}