{"ast":null,"code":"const {\n  crc16,\n  hexToBytes,\n  bytesToHex,\n  stringToBytes,\n  base64toString,\n  stringToBase64\n} = require(\"./Utils\");\n\nconst bounceable_tag = 0x11;\nconst non_bounceable_tag = 0x51;\nconst test_flag = 0x80;\n/**\n * @private\n * @param addressString {string}\n * @return {{isTestOnly: boolean, workchain: number, hashPart: Uint8Array, isBounceable: boolean}}\n */\n\nfunction parseFriendlyAddress(addressString) {\n  if (addressString.length !== 48) {\n    throw new Error(`User-friendly address should contain strictly 48 characters`);\n  }\n\n  const data = stringToBytes(base64toString(addressString));\n\n  if (data.length !== 36) {\n    // 1byte tag + 1byte workchain + 32 bytes hash + 2 byte crc\n    throw \"Unknown address type: byte length is not equal to 36\";\n  }\n\n  const addr = data.slice(0, 34);\n  const crc = data.slice(34, 36);\n  const calcedCrc = crc16(addr);\n\n  if (!(calcedCrc[0] === crc[0] && calcedCrc[1] === crc[1])) {\n    throw \"Wrong crc16 hashsum\";\n  }\n\n  let tag = addr[0];\n  let isTestOnly = false;\n  let isBounceable = false;\n\n  if (tag & test_flag) {\n    isTestOnly = true;\n    tag = tag ^ test_flag;\n  }\n\n  if (tag !== bounceable_tag && tag !== non_bounceable_tag) throw \"Unknown address tag\";\n  isBounceable = tag === bounceable_tag;\n  let workchain = null;\n\n  if (addr[1] === 0xff) {\n    // TODO we should read signed integer here\n    workchain = -1;\n  } else {\n    workchain = addr[1];\n  }\n\n  if (workchain !== 0 && workchain !== -1) throw new Error('Invalid address wc ' + workchain);\n  const hashPart = addr.slice(2, 34);\n  return {\n    isTestOnly,\n    isBounceable,\n    workchain,\n    hashPart\n  };\n}\n\nclass Address {\n  /**\n   * @param anyForm {string | Address}\n   */\n  static isValid(anyForm) {\n    try {\n      new Address(anyForm);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  /**\n   * @param anyForm {string | Address}\n   */\n\n\n  constructor(anyForm) {\n    if (anyForm == null) {\n      throw \"Invalid address\";\n    }\n\n    if (anyForm instanceof Address) {\n      this.wc = anyForm.wc;\n      this.hashPart = anyForm.hashPart;\n      this.isTestOnly = anyForm.isTestOnly;\n      this.isUserFriendly = anyForm.isUserFriendly;\n      this.isBounceable = anyForm.isBounceable;\n      this.isUrlSafe = anyForm.isUrlSafe;\n      return;\n    }\n\n    if (anyForm.search(/\\-/) > 0 || anyForm.search(/_/) > 0) {\n      this.isUrlSafe = true;\n      anyForm = anyForm.replace(/\\-/g, '+').replace(/_/g, '\\/');\n    } else {\n      this.isUrlSafe = false;\n    }\n\n    if (anyForm.indexOf(':') > -1) {\n      const arr = anyForm.split(':');\n      if (arr.length !== 2) throw new Error('Invalid address ' + anyForm);\n      const wc = parseInt(arr[0]);\n      if (wc !== 0 && wc !== -1) throw new Error('Invalid address wc ' + anyForm);\n      const hex = arr[1];\n      if (hex.length !== 64) throw new Error('Invalid address hex ' + anyForm);\n      this.isUserFriendly = false;\n      this.wc = wc;\n      this.hashPart = hexToBytes(hex);\n      this.isTestOnly = false;\n      this.isBounceable = false;\n    } else {\n      this.isUserFriendly = true;\n      const parseResult = parseFriendlyAddress(anyForm);\n      this.wc = parseResult.workchain;\n      this.hashPart = parseResult.hashPart;\n      this.isTestOnly = parseResult.isTestOnly;\n      this.isBounceable = parseResult.isBounceable;\n    }\n  }\n  /**\n   * @param isUserFriendly? {boolean}\n   * @param isUrlSafe? {boolean}\n   * @param isBounceable? {boolean}\n   * @param isTestOnly? {boolean}\n   * @return {string}\n   */\n\n\n  toString(isUserFriendly, isUrlSafe, isBounceable, isTestOnly) {\n    if (isUserFriendly === undefined) isUserFriendly = this.isUserFriendly;\n    if (isUrlSafe === undefined) isUrlSafe = this.isUrlSafe;\n    if (isBounceable === undefined) isBounceable = this.isBounceable;\n    if (isTestOnly === undefined) isTestOnly = this.isTestOnly;\n\n    if (!isUserFriendly) {\n      return this.wc + \":\" + bytesToHex(this.hashPart);\n    } else {\n      let tag = isBounceable ? bounceable_tag : non_bounceable_tag;\n\n      if (isTestOnly) {\n        tag |= test_flag;\n      }\n\n      const addr = new Int8Array(34);\n      addr[0] = tag;\n      addr[1] = this.wc;\n      addr.set(this.hashPart, 2);\n      const addressWithChecksum = new Uint8Array(36);\n      addressWithChecksum.set(addr);\n      addressWithChecksum.set(crc16(addr), 34);\n      let addressBase64 = stringToBase64(String.fromCharCode.apply(null, new Uint8Array(addressWithChecksum)));\n\n      if (isUrlSafe) {\n        addressBase64 = addressBase64.replace(/\\+/g, '-').replace(/\\//g, '_');\n      }\n\n      return addressBase64;\n    }\n  }\n\n}\n\nmodule.exports.default = Address;","map":{"version":3,"names":["crc16","hexToBytes","bytesToHex","stringToBytes","base64toString","stringToBase64","require","bounceable_tag","non_bounceable_tag","test_flag","parseFriendlyAddress","addressString","length","Error","data","addr","slice","crc","calcedCrc","tag","isTestOnly","isBounceable","workchain","hashPart","Address","isValid","anyForm","e","constructor","wc","isUserFriendly","isUrlSafe","search","replace","indexOf","arr","split","parseInt","hex","parseResult","toString","undefined","Int8Array","set","addressWithChecksum","Uint8Array","addressBase64","String","fromCharCode","apply","module","exports","default"],"sources":["/home/rybakisa/Desktop/TEMP/HackaTON/TON Ads/ton-ads/node_modules/tonweb/src/utils/Address.js"],"sourcesContent":["const {crc16, hexToBytes, bytesToHex, stringToBytes, base64toString, stringToBase64} = require(\"./Utils\");\n\nconst bounceable_tag = 0x11;\nconst non_bounceable_tag = 0x51;\nconst test_flag = 0x80;\n\n/**\n * @private\n * @param addressString {string}\n * @return {{isTestOnly: boolean, workchain: number, hashPart: Uint8Array, isBounceable: boolean}}\n */\nfunction parseFriendlyAddress(addressString) {\n    if (addressString.length !== 48) {\n        throw new Error(`User-friendly address should contain strictly 48 characters`);\n    }\n    const data = stringToBytes(base64toString(addressString));\n    if (data.length !== 36) { // 1byte tag + 1byte workchain + 32 bytes hash + 2 byte crc\n        throw \"Unknown address type: byte length is not equal to 36\";\n    }\n    const addr = data.slice(0, 34);\n    const crc = data.slice(34, 36);\n    const calcedCrc = crc16(addr);\n    if (!(calcedCrc[0] === crc[0] && calcedCrc[1] === crc[1])) {\n        throw \"Wrong crc16 hashsum\";\n    }\n    let tag = addr[0];\n    let isTestOnly = false;\n    let isBounceable = false;\n    if (tag & test_flag) {\n        isTestOnly = true;\n        tag = tag ^ test_flag;\n    }\n    if ((tag !== bounceable_tag) && (tag !== non_bounceable_tag))\n        throw \"Unknown address tag\";\n\n    isBounceable = tag === bounceable_tag;\n\n    let workchain = null;\n    if (addr[1] === 0xff) { // TODO we should read signed integer here\n        workchain = -1;\n    } else {\n        workchain = addr[1];\n    }\n    if (workchain !== 0 && workchain !== -1) throw new Error('Invalid address wc ' + workchain);\n\n    const hashPart = addr.slice(2, 34);\n    return {isTestOnly, isBounceable, workchain, hashPart};\n}\n\nclass Address {\n    /**\n     * @param anyForm {string | Address}\n     */\n    static isValid(anyForm) {\n        try {\n            new Address(anyForm);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * @param anyForm {string | Address}\n     */\n    constructor(anyForm) {\n        if (anyForm == null) {\n            throw \"Invalid address\";\n        }\n\n        if (anyForm instanceof Address) {\n            this.wc = anyForm.wc;\n            this.hashPart = anyForm.hashPart;\n            this.isTestOnly = anyForm.isTestOnly;\n            this.isUserFriendly = anyForm.isUserFriendly;\n            this.isBounceable = anyForm.isBounceable;\n            this.isUrlSafe = anyForm.isUrlSafe;\n            return;\n        }\n\n        if (anyForm.search(/\\-/) > 0 || anyForm.search(/_/) > 0) {\n            this.isUrlSafe = true;\n            anyForm = anyForm.replace(/\\-/g, '+').replace(/_/g, '\\/');\n        } else {\n            this.isUrlSafe = false;\n        }\n        if (anyForm.indexOf(':') > -1) {\n            const arr = anyForm.split(':');\n            if (arr.length !== 2) throw new Error('Invalid address ' + anyForm);\n            const wc = parseInt(arr[0]);\n            if (wc !== 0 && wc !== -1) throw new Error('Invalid address wc ' + anyForm);\n            const hex = arr[1];\n            if (hex.length !== 64) throw new Error('Invalid address hex ' + anyForm);\n            this.isUserFriendly = false;\n            this.wc = wc;\n            this.hashPart = hexToBytes(hex);\n            this.isTestOnly = false;\n            this.isBounceable = false;\n        } else {\n            this.isUserFriendly = true;\n            const parseResult = parseFriendlyAddress(anyForm);\n            this.wc = parseResult.workchain;\n            this.hashPart = parseResult.hashPart;\n            this.isTestOnly = parseResult.isTestOnly;\n            this.isBounceable = parseResult.isBounceable;\n        }\n    }\n\n    /**\n     * @param isUserFriendly? {boolean}\n     * @param isUrlSafe? {boolean}\n     * @param isBounceable? {boolean}\n     * @param isTestOnly? {boolean}\n     * @return {string}\n     */\n    toString(isUserFriendly,\n             isUrlSafe,\n             isBounceable,\n             isTestOnly) {\n\n        if (isUserFriendly === undefined) isUserFriendly = this.isUserFriendly;\n        if (isUrlSafe === undefined) isUrlSafe = this.isUrlSafe;\n        if (isBounceable === undefined) isBounceable = this.isBounceable;\n        if (isTestOnly === undefined) isTestOnly = this.isTestOnly;\n\n        if (!isUserFriendly) {\n            return this.wc + \":\" + bytesToHex(this.hashPart);\n        } else {\n            let tag = isBounceable ? bounceable_tag : non_bounceable_tag;\n            if (isTestOnly) {\n                tag |= test_flag;\n            }\n\n            const addr = new Int8Array(34);\n            addr[0] = tag;\n            addr[1] = this.wc;\n            addr.set(this.hashPart, 2);\n\n            const addressWithChecksum = new Uint8Array(36);\n            addressWithChecksum.set(addr);\n            addressWithChecksum.set(crc16(addr), 34);\n            let addressBase64 = stringToBase64(String.fromCharCode.apply(null, new Uint8Array(addressWithChecksum)));\n\n            if (isUrlSafe) {\n                addressBase64 = addressBase64.replace(/\\+/g, '-').replace(/\\//g, '_');\n            }\n            return addressBase64;\n        }\n    }\n}\n\nmodule.exports.default = Address;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}