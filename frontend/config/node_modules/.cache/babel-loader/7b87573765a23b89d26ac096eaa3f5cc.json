{"ast":null,"code":"/**\n * Storage for storing block numbers that we have already processed.\n * Used by `BlockSubscription`.\n *\n * Dumb in-memory implementation.\n */\nclass InMemoryBlockStorage {\n  /**\n   * @param logFunction?   {(text: string) => void}\n   */\n  constructor(logFunction) {\n    this.masterchainBlocks = {}; // mcBlockNumber {number} -> isProcessed {boolean}\n\n    this.shardchainBlocks = {}; // workchain {number} + shardId {string} + shardBlockNumber {number} -> isProcessed {boolean}\n\n    this.logFunction = logFunction;\n  }\n  /**\n   * @private\n   * Insert new UNprocessed shardchain block numbers\n   * Block number (workchain + shardId + shardBlockNumber) should be IGNORED if it is already in the storage\n   * @param   shardBlockNumbers {[{workchain: number, shardId: string, shardBlockNumber: number}]}\n   */\n\n\n  async insertShardBlocks(shardBlockNumbers) {\n    for (const {\n      workchain,\n      shardId,\n      shardBlockNumber\n    } of shardBlockNumbers) {\n      if (this.shardchainBlocks[workchain + '_' + shardId + '_' + shardBlockNumber] !== undefined) continue;\n\n      if (this.logFunction) {\n        this.logFunction('insert shard ' + workchain + ' ' + shardId + ' ' + shardBlockNumber);\n      } // INSERT INTO shardchainBlocks VALUES (workchain, shardId, shardBlockNumber, FALSE);\n\n\n      this.shardchainBlocks[workchain + '_' + shardId + '_' + shardBlockNumber] = false;\n    }\n  }\n  /**\n   * Insert new processed masterchain block number & new UNprocessed shardchains blocks numbers\n   * Must be in single DB transaction\n   * @param   mcBlockNumber {number}\n   * @param   shardBlockNumbers {[{workchain: number, shardId: string, shardBlockNumber: number}]}\n   */\n\n\n  async insertBlocks(mcBlockNumber, shardBlockNumbers) {\n    if (this.logFunction) {\n      this.logFunction('mc processed ' + mcBlockNumber);\n    } // INSERT INTO masterchainBlocks VALUES (blockNumber, TRUE);\n\n\n    if (this.masterchainBlocks[mcBlockNumber] !== undefined) throw new Error('mc already exists ' + mcBlockNumber);\n    this.masterchainBlocks[mcBlockNumber] = true;\n    await this.insertShardBlocks(shardBlockNumbers);\n  }\n  /**\n   * Get last processed masterchain block number\n   * @return {Promise<number | undefined>}\n   */\n\n\n  async getLastMasterchainBlockNumber() {\n    // SELECT MAX(blockNumber) FROM masterchainBlocks\n    const blockNumbers = Object.keys(this.masterchainBlocks).map(x => Number(x)).sort((a, b) => b - a);\n    return blockNumbers[0];\n  }\n  /**\n   * Set that this shardchain block number processed & insert new UNprocessed shardchains blocks numbers\n   * Must be in single DB transaction\n   * @param   workchain {number}\n   * @param   shardId {string}\n   * @param   shardBlockNumber    {number}\n   * @param   prevShardBlocks    {[{workchain: number, shardId: string, shardBlockNumber: number}]}\n   */\n\n\n  async setBlockProcessed(workchain, shardId, shardBlockNumber, prevShardBlocks) {\n    if (this.logFunction) {\n      this.logFunction('shard processed ' + workchain + ' ' + shardId + ' ' + shardBlockNumber);\n    } // UPDATE shardchainBlocks SET processed = TRUE WHERE workchain = ? AND shardId = ? AND shardBlockNumber = ?\n\n\n    if (this.shardchainBlocks[workchain + '_' + shardId + '_' + shardBlockNumber] === undefined) throw new Error('shard not exists ' + workchain + '_' + shardId + '_' + shardBlockNumber);\n    this.shardchainBlocks[workchain + '_' + shardId + '_' + shardBlockNumber] = true;\n    await this.insertShardBlocks(prevShardBlocks);\n  }\n  /**\n   * Get any unprocesed shard block number (order is not important)\n   * @return {Promise<{workchain: number, shardId: string, shardBlockNumber: number}>}\n   */\n\n\n  async getUnprocessedShardBlock() {\n    // SELECT workchain, shardId, shardBlockNumber from sharchainBlocks WHERE processed = FALSE LIMIT 1\n    for (let key in this.shardchainBlocks) {\n      if (this.shardchainBlocks[key] === false) {\n        const arr = key.split('_');\n        return {\n          workchain: Number(arr[0]),\n          shardId: arr[1],\n          shardBlockNumber: Number(arr[2])\n        };\n      }\n    }\n\n    return undefined;\n  }\n\n}\n\nmodule.exports = {\n  InMemoryBlockStorage\n};","map":{"version":3,"names":["InMemoryBlockStorage","constructor","logFunction","masterchainBlocks","shardchainBlocks","insertShardBlocks","shardBlockNumbers","workchain","shardId","shardBlockNumber","undefined","insertBlocks","mcBlockNumber","Error","getLastMasterchainBlockNumber","blockNumbers","Object","keys","map","x","Number","sort","a","b","setBlockProcessed","prevShardBlocks","getUnprocessedShardBlock","key","arr","split","module","exports"],"sources":["/home/rybakisa/Desktop/TEMP/HackaTON/TON Ads/ton-ads/node_modules/tonweb/src/providers/blockSubscription/InMemoryBlockStorage.js"],"sourcesContent":["/**\n * Storage for storing block numbers that we have already processed.\n * Used by `BlockSubscription`.\n *\n * Dumb in-memory implementation.\n */\nclass InMemoryBlockStorage {\n\n    /**\n     * @param logFunction?   {(text: string) => void}\n     */\n    constructor(logFunction) {\n        this.masterchainBlocks = {}; // mcBlockNumber {number} -> isProcessed {boolean}\n        this.shardchainBlocks = {}; // workchain {number} + shardId {string} + shardBlockNumber {number} -> isProcessed {boolean}\n        this.logFunction = logFunction;\n    }\n\n    /**\n     * @private\n     * Insert new UNprocessed shardchain block numbers\n     * Block number (workchain + shardId + shardBlockNumber) should be IGNORED if it is already in the storage\n     * @param   shardBlockNumbers {[{workchain: number, shardId: string, shardBlockNumber: number}]}\n     */\n    async insertShardBlocks(shardBlockNumbers) {\n        for (const {workchain, shardId, shardBlockNumber} of shardBlockNumbers) {\n            if (this.shardchainBlocks[workchain + '_' + shardId + '_' + shardBlockNumber] !== undefined) continue;\n            if (this.logFunction) {\n                this.logFunction('insert shard ' + workchain + ' ' + shardId + ' ' + shardBlockNumber);\n            }\n            // INSERT INTO shardchainBlocks VALUES (workchain, shardId, shardBlockNumber, FALSE);\n            this.shardchainBlocks[workchain + '_' + shardId + '_' + shardBlockNumber] = false;\n        }\n    }\n\n    /**\n     * Insert new processed masterchain block number & new UNprocessed shardchains blocks numbers\n     * Must be in single DB transaction\n     * @param   mcBlockNumber {number}\n     * @param   shardBlockNumbers {[{workchain: number, shardId: string, shardBlockNumber: number}]}\n     */\n    async insertBlocks(mcBlockNumber, shardBlockNumbers) {\n        if (this.logFunction) {\n            this.logFunction('mc processed ' + mcBlockNumber);\n        }\n        // INSERT INTO masterchainBlocks VALUES (blockNumber, TRUE);\n        if (this.masterchainBlocks[mcBlockNumber] !== undefined) throw new Error('mc already exists ' + mcBlockNumber);\n        this.masterchainBlocks[mcBlockNumber] = true;\n\n        await this.insertShardBlocks(shardBlockNumbers);\n    }\n\n    /**\n     * Get last processed masterchain block number\n     * @return {Promise<number | undefined>}\n     */\n    async getLastMasterchainBlockNumber() {\n        // SELECT MAX(blockNumber) FROM masterchainBlocks\n        const blockNumbers = Object.keys(this.masterchainBlocks)\n            .map(x => Number(x))\n            .sort((a, b) => b - a);\n        return blockNumbers[0];\n    }\n\n    /**\n     * Set that this shardchain block number processed & insert new UNprocessed shardchains blocks numbers\n     * Must be in single DB transaction\n     * @param   workchain {number}\n     * @param   shardId {string}\n     * @param   shardBlockNumber    {number}\n     * @param   prevShardBlocks    {[{workchain: number, shardId: string, shardBlockNumber: number}]}\n     */\n    async setBlockProcessed(workchain, shardId, shardBlockNumber, prevShardBlocks) {\n        if (this.logFunction) {\n            this.logFunction('shard processed ' + workchain + ' ' + shardId + ' ' + shardBlockNumber);\n        }\n        // UPDATE shardchainBlocks SET processed = TRUE WHERE workchain = ? AND shardId = ? AND shardBlockNumber = ?\n        if (this.shardchainBlocks[workchain + '_' + shardId + '_' + shardBlockNumber] === undefined) throw new Error('shard not exists ' + workchain + '_' + shardId + '_' + shardBlockNumber);\n        this.shardchainBlocks[workchain + '_' + shardId + '_' + shardBlockNumber] = true;\n\n        await this.insertShardBlocks(prevShardBlocks);\n    }\n\n    /**\n     * Get any unprocesed shard block number (order is not important)\n     * @return {Promise<{workchain: number, shardId: string, shardBlockNumber: number}>}\n     */\n    async getUnprocessedShardBlock() {\n        // SELECT workchain, shardId, shardBlockNumber from sharchainBlocks WHERE processed = FALSE LIMIT 1\n        for (let key in this.shardchainBlocks) {\n            if (this.shardchainBlocks[key] === false) {\n                const arr = key.split('_');\n                return {\n                    workchain: Number(arr[0]),\n                    shardId: arr[1],\n                    shardBlockNumber: Number(arr[2]),\n                }\n            }\n        }\n        return undefined;\n    }\n\n}\n\nmodule.exports = {InMemoryBlockStorage};"],"mappings":"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"},"metadata":{},"sourceType":"script"}