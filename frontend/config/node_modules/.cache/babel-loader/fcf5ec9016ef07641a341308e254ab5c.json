{"ast":null,"code":"const {\n  Contract\n} = require(\"../index.js\");\n\nconst {\n  Cell\n} = require(\"../../boc\");\n\nconst {\n  nacl,\n  stringToBytes,\n  Address,\n  BN\n} = require(\"../../utils\");\n/**\n * Abstract standard wallet class\n */\n\n\nclass WalletContract extends Contract {\n  /**\n   * @param provider    {HttpProvider}\n   * @param options?    {{code: Uint8Array, publicKey?: Uint8Array, address?: Address | string, wc?: number}}\n   */\n  constructor(provider, options) {\n    if (!options.publicKey && !options.address) throw new Error('WalletContract required publicKey or address in options');\n    super(provider, options);\n    this.methods = {\n      /**\n       * @param   params {{secretKey: Uint8Array, toAddress: Address | string, amount: BN | number, seqno: number, payload: string | Uint8Array | Cell, sendMode: number, stateInit?: Cell}}\n       */\n      transfer: params => Contract.createMethod(provider, this.createTransferMessage(params.secretKey, params.toAddress, params.amount, params.seqno, params.payload, params.sendMode, !Boolean(params.secretKey), params.stateInit)),\n      seqno: () => {\n        return {\n          /**\n           * @return {Promise<number>}\n           */\n          call: async () => {\n            const address = await this.getAddress();\n            let n = null;\n\n            try {\n              n = (await provider.call2(address.toString(), 'seqno')).toNumber();\n            } catch (e) {}\n\n            return n;\n          }\n        };\n      }\n    };\n    /**\n     * @param secretKey {Uint8Array}\n     */\n\n    this.deploy = secretKey => Contract.createMethod(provider, this.createInitExternalMessage(secretKey));\n  }\n\n  getName() {\n    throw new Error('override me');\n  }\n  /**\n   * @override\n   * @protected\n   * @return {Cell} cell contains wallet data\n   */\n\n\n  createDataCell() {\n    // 4 byte seqno, 32 byte publicKey\n    const cell = new Cell();\n    cell.bits.writeUint(0, 32); // seqno\n\n    cell.bits.writeBytes(this.options.publicKey);\n    return cell;\n  }\n  /**\n   * @protected\n   * @param   seqno?   {number}\n   * @return {Cell}\n   */\n\n\n  createSigningMessage(seqno) {\n    seqno = seqno || 0;\n    const cell = new Cell();\n    cell.bits.writeUint(seqno, 32);\n    return cell;\n  }\n  /**\n   * External message for initialization\n   * @param secretKey  {Uint8Array} nacl.KeyPair.secretKey\n   * @return {{address: Address, message: Cell, body: Cell, sateInit: Cell, code: Cell, data: Cell}}\n   */\n\n\n  async createInitExternalMessage(secretKey) {\n    if (!this.options.publicKey) {\n      const keyPair = nacl.sign.keyPair.fromSecretKey(secretKey);\n      this.options.publicKey = keyPair.publicKey;\n    }\n\n    const {\n      stateInit,\n      address,\n      code,\n      data\n    } = await this.createStateInit();\n    const signingMessage = this.createSigningMessage();\n    const signature = nacl.sign.detached(await signingMessage.hash(), secretKey);\n    const body = new Cell();\n    body.bits.writeBytes(signature);\n    body.writeCell(signingMessage);\n    const header = Contract.createExternalMessageHeader(address);\n    const externalMessage = Contract.createCommonMsgInfo(header, stateInit, body);\n    return {\n      address: address,\n      message: externalMessage,\n      body,\n      signingMessage,\n      stateInit,\n      code,\n      data\n    };\n  }\n  /**\n   * @protected\n   * @param signingMessage {Cell}\n   * @param secretKey {Uint8Array}  nacl.KeyPair.secretKey\n   * @param seqno {number}\n   * @param dummySignature?    {boolean}\n   * @return {Promise<{address: Address, signature: Uint8Array, message: Cell, cell: Cell, body: Cell, resultMessage: Cell}>}\n   */\n\n\n  async createExternalMessage(signingMessage, secretKey, seqno) {\n    let dummySignature = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    const signature = dummySignature ? new Uint8Array(64) : nacl.sign.detached(await signingMessage.hash(), secretKey);\n    const body = new Cell();\n    body.bits.writeBytes(signature);\n    body.writeCell(signingMessage);\n    let stateInit = null,\n        code = null,\n        data = null;\n\n    if (seqno === 0) {\n      if (!this.options.publicKey) {\n        const keyPair = nacl.sign.keyPair.fromSecretKey(secretKey);\n        this.options.publicKey = keyPair.publicKey;\n      }\n\n      const deploy = await this.createStateInit();\n      stateInit = deploy.stateInit;\n      code = deploy.code;\n      data = deploy.data;\n    }\n\n    const selfAddress = await this.getAddress();\n    const header = Contract.createExternalMessageHeader(selfAddress);\n    const resultMessage = Contract.createCommonMsgInfo(header, stateInit, body);\n    return {\n      address: selfAddress,\n      message: resultMessage,\n      // old wallet_send_generate_external_message\n      body: body,\n      signature: signature,\n      signingMessage: signingMessage,\n      stateInit,\n      code,\n      data\n    };\n  }\n  /**\n   * @param secretKey {Uint8Array}  nacl.KeyPair.secretKey\n   * @param address   {Address | string}\n   * @param amount    {BN | number} in nanograms\n   * @param seqno {number}\n   * @param payload?   {string | Uint8Array | Cell}\n   * @param sendMode?  {number}\n   * @param dummySignature?    {boolean}\n   * @param stateInit? {Cell}\n   * @return {Promise<{address: Address, signature: Uint8Array, message: Cell, cell: Cell, body: Cell, resultMessage: Cell}>}\n   */\n\n\n  async createTransferMessage(secretKey, address, amount, seqno) {\n    let payload = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"\";\n    let sendMode = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 3;\n    let dummySignature = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n    let stateInit = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;\n    let payloadCell = new Cell();\n\n    if (payload) {\n      if (payload.refs) {\n        // is Cell\n        payloadCell = payload;\n      } else if (typeof payload === 'string') {\n        if (payload.length > 0) {\n          payloadCell.bits.writeUint(0, 32);\n          payloadCell.bits.writeString(payload);\n        }\n      } else {\n        payloadCell.bits.writeBytes(payload);\n      }\n    }\n\n    const orderHeader = Contract.createInternalMessageHeader(new Address(address), new BN(amount));\n    const order = Contract.createCommonMsgInfo(orderHeader, stateInit, payloadCell);\n    const signingMessage = this.createSigningMessage(seqno);\n    signingMessage.bits.writeUint8(sendMode);\n    signingMessage.refs.push(order);\n    return this.createExternalMessage(signingMessage, secretKey, seqno, dummySignature);\n  }\n\n}\n\nmodule.exports = {\n  WalletContract\n};","map":{"version":3,"names":["Contract","require","Cell","nacl","stringToBytes","Address","BN","WalletContract","constructor","provider","options","publicKey","address","Error","methods","transfer","params","createMethod","createTransferMessage","secretKey","toAddress","amount","seqno","payload","sendMode","Boolean","stateInit","call","getAddress","n","call2","toString","toNumber","e","deploy","createInitExternalMessage","getName","createDataCell","cell","bits","writeUint","writeBytes","createSigningMessage","keyPair","sign","fromSecretKey","code","data","createStateInit","signingMessage","signature","detached","hash","body","writeCell","header","createExternalMessageHeader","externalMessage","createCommonMsgInfo","message","createExternalMessage","dummySignature","Uint8Array","selfAddress","resultMessage","payloadCell","refs","length","writeString","orderHeader","createInternalMessageHeader","order","writeUint8","push","module","exports"],"sources":["/home/rybakisa/Desktop/TEMP/HackaTON/TON Ads/ton-ads/node_modules/tonweb/src/contract/wallet/WalletContract.js"],"sourcesContent":["const {Contract} = require(\"../index.js\");\nconst {Cell} = require(\"../../boc\");\nconst {nacl, stringToBytes, Address, BN} = require(\"../../utils\");\n\n/**\n * Abstract standard wallet class\n */\nclass WalletContract extends Contract {\n    /**\n     * @param provider    {HttpProvider}\n     * @param options?    {{code: Uint8Array, publicKey?: Uint8Array, address?: Address | string, wc?: number}}\n     */\n    constructor(provider, options) {\n        if (!options.publicKey && !options.address) throw new Error('WalletContract required publicKey or address in options')\n        super(provider, options);\n\n        this.methods = {\n            /**\n             * @param   params {{secretKey: Uint8Array, toAddress: Address | string, amount: BN | number, seqno: number, payload: string | Uint8Array | Cell, sendMode: number, stateInit?: Cell}}\n             */\n            transfer: (params) => Contract.createMethod(provider, this.createTransferMessage(params.secretKey, params.toAddress, params.amount, params.seqno, params.payload, params.sendMode, !Boolean(params.secretKey), params.stateInit)),\n\n            seqno: () => {\n                return {\n                    /**\n                     * @return {Promise<number>}\n                     */\n                    call: async () => {\n                        const address = await this.getAddress();\n                        let n = null;\n                        try {\n                            n = (await provider.call2(address.toString(), 'seqno')).toNumber();\n                        } catch (e) {\n                        }\n                        return n;\n                    }\n                }\n            }\n        }\n\n        /**\n         * @param secretKey {Uint8Array}\n         */\n        this.deploy = (secretKey) => Contract.createMethod(provider, this.createInitExternalMessage(secretKey));\n    }\n\n    getName() {\n        throw new Error('override me');\n    }\n\n    /**\n     * @override\n     * @protected\n     * @return {Cell} cell contains wallet data\n     */\n    createDataCell() {\n        // 4 byte seqno, 32 byte publicKey\n        const cell = new Cell();\n        cell.bits.writeUint(0, 32); // seqno\n        cell.bits.writeBytes(this.options.publicKey);\n        return cell;\n    }\n\n    /**\n     * @protected\n     * @param   seqno?   {number}\n     * @return {Cell}\n     */\n    createSigningMessage(seqno) {\n        seqno = seqno || 0;\n        const cell = new Cell();\n        cell.bits.writeUint(seqno, 32);\n        return cell;\n    }\n\n    /**\n     * External message for initialization\n     * @param secretKey  {Uint8Array} nacl.KeyPair.secretKey\n     * @return {{address: Address, message: Cell, body: Cell, sateInit: Cell, code: Cell, data: Cell}}\n     */\n    async createInitExternalMessage(secretKey) {\n        if (!this.options.publicKey) {\n            const keyPair = nacl.sign.keyPair.fromSecretKey(secretKey)\n            this.options.publicKey = keyPair.publicKey;\n        }\n        const {stateInit, address, code, data} = await this.createStateInit();\n\n        const signingMessage = this.createSigningMessage();\n        const signature = nacl.sign.detached(await signingMessage.hash(), secretKey);\n\n        const body = new Cell();\n        body.bits.writeBytes(signature);\n        body.writeCell(signingMessage);\n\n        const header = Contract.createExternalMessageHeader(address);\n        const externalMessage = Contract.createCommonMsgInfo(header, stateInit, body);\n\n        return {\n            address: address,\n            message: externalMessage,\n\n            body,\n            signingMessage,\n            stateInit,\n            code,\n            data,\n        };\n    }\n\n    /**\n     * @protected\n     * @param signingMessage {Cell}\n     * @param secretKey {Uint8Array}  nacl.KeyPair.secretKey\n     * @param seqno {number}\n     * @param dummySignature?    {boolean}\n     * @return {Promise<{address: Address, signature: Uint8Array, message: Cell, cell: Cell, body: Cell, resultMessage: Cell}>}\n     */\n    async createExternalMessage(\n        signingMessage,\n        secretKey,\n        seqno,\n        dummySignature = false\n    ) {\n        const signature = dummySignature ? new Uint8Array(64) : nacl.sign.detached(await signingMessage.hash(), secretKey);\n\n        const body = new Cell();\n        body.bits.writeBytes(signature);\n        body.writeCell(signingMessage);\n\n        let stateInit = null, code = null, data = null;\n\n        if (seqno === 0) {\n            if (!this.options.publicKey) {\n                const keyPair = nacl.sign.keyPair.fromSecretKey(secretKey)\n                this.options.publicKey = keyPair.publicKey;\n            }\n            const deploy = await this.createStateInit();\n            stateInit = deploy.stateInit;\n            code = deploy.code;\n            data = deploy.data;\n        }\n\n        const selfAddress = await this.getAddress();\n        const header = Contract.createExternalMessageHeader(selfAddress);\n        const resultMessage = Contract.createCommonMsgInfo(header, stateInit, body);\n\n        return {\n            address: selfAddress,\n            message: resultMessage, // old wallet_send_generate_external_message\n\n            body: body,\n            signature: signature,\n            signingMessage: signingMessage,\n\n            stateInit,\n            code,\n            data,\n        };\n    }\n\n    /**\n     * @param secretKey {Uint8Array}  nacl.KeyPair.secretKey\n     * @param address   {Address | string}\n     * @param amount    {BN | number} in nanograms\n     * @param seqno {number}\n     * @param payload?   {string | Uint8Array | Cell}\n     * @param sendMode?  {number}\n     * @param dummySignature?    {boolean}\n     * @param stateInit? {Cell}\n     * @return {Promise<{address: Address, signature: Uint8Array, message: Cell, cell: Cell, body: Cell, resultMessage: Cell}>}\n     */\n    async createTransferMessage(\n        secretKey,\n        address,\n        amount,\n        seqno,\n        payload = \"\",\n        sendMode = 3,\n        dummySignature = false,\n        stateInit = null\n    ) {\n        let payloadCell = new Cell();\n        if (payload) {\n            if (payload.refs) { // is Cell\n                payloadCell = payload;\n            } else if (typeof payload === 'string') {\n                if (payload.length > 0) {\n                    payloadCell.bits.writeUint(0, 32);\n                    payloadCell.bits.writeString(payload);\n                }\n            } else {\n                payloadCell.bits.writeBytes(payload)\n            }\n        }\n\n        const orderHeader = Contract.createInternalMessageHeader(new Address(address), new BN(amount));\n        const order = Contract.createCommonMsgInfo(orderHeader, stateInit, payloadCell);\n        const signingMessage = this.createSigningMessage(seqno);\n        signingMessage.bits.writeUint8(sendMode);\n        signingMessage.refs.push(order);\n\n        return this.createExternalMessage(signingMessage, secretKey, seqno, dummySignature);\n    }\n}\n\nmodule.exports = {WalletContract};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}