{"ast":null,"code":"/** PURE_IMPORTS_START tslib,_Subject,_scheduler_queue,_Subscription,_operators_observeOn,_util_ObjectUnsubscribedError,_SubjectSubscription PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subject } from './Subject';\nimport { queue } from './scheduler/queue';\nimport { Subscription } from './Subscription';\nimport { ObserveOnSubscriber } from './operators/observeOn';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { SubjectSubscription } from './SubjectSubscription';\n\nvar ReplaySubject = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(ReplaySubject, _super);\n\n  function ReplaySubject(bufferSize, windowTime, scheduler) {\n    if (bufferSize === void 0) {\n      bufferSize = Number.POSITIVE_INFINITY;\n    }\n\n    if (windowTime === void 0) {\n      windowTime = Number.POSITIVE_INFINITY;\n    }\n\n    var _this = _super.call(this) || this;\n\n    _this.scheduler = scheduler;\n    _this._events = [];\n    _this._infiniteTimeWindow = false;\n    _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n    _this._windowTime = windowTime < 1 ? 1 : windowTime;\n\n    if (windowTime === Number.POSITIVE_INFINITY) {\n      _this._infiniteTimeWindow = true;\n      _this.next = _this.nextInfiniteTimeWindow;\n    } else {\n      _this.next = _this.nextTimeWindow;\n    }\n\n    return _this;\n  }\n\n  ReplaySubject.prototype.nextInfiniteTimeWindow = function (value) {\n    if (!this.isStopped) {\n      var _events = this._events;\n\n      _events.push(value);\n\n      if (_events.length > this._bufferSize) {\n        _events.shift();\n      }\n    }\n\n    _super.prototype.next.call(this, value);\n  };\n\n  ReplaySubject.prototype.nextTimeWindow = function (value) {\n    if (!this.isStopped) {\n      this._events.push(new ReplayEvent(this._getNow(), value));\n\n      this._trimBufferThenGetEvents();\n    }\n\n    _super.prototype.next.call(this, value);\n  };\n\n  ReplaySubject.prototype._subscribe = function (subscriber) {\n    var _infiniteTimeWindow = this._infiniteTimeWindow;\n\n    var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();\n\n    var scheduler = this.scheduler;\n    var len = _events.length;\n    var subscription;\n\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    } else if (this.isStopped || this.hasError) {\n      subscription = Subscription.EMPTY;\n    } else {\n      this.observers.push(subscriber);\n      subscription = new SubjectSubscription(this, subscriber);\n    }\n\n    if (scheduler) {\n      subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));\n    }\n\n    if (_infiniteTimeWindow) {\n      for (var i = 0; i < len && !subscriber.closed; i++) {\n        subscriber.next(_events[i]);\n      }\n    } else {\n      for (var i = 0; i < len && !subscriber.closed; i++) {\n        subscriber.next(_events[i].value);\n      }\n    }\n\n    if (this.hasError) {\n      subscriber.error(this.thrownError);\n    } else if (this.isStopped) {\n      subscriber.complete();\n    }\n\n    return subscription;\n  };\n\n  ReplaySubject.prototype._getNow = function () {\n    return (this.scheduler || queue).now();\n  };\n\n  ReplaySubject.prototype._trimBufferThenGetEvents = function () {\n    var now = this._getNow();\n\n    var _bufferSize = this._bufferSize;\n    var _windowTime = this._windowTime;\n    var _events = this._events;\n    var eventsCount = _events.length;\n    var spliceCount = 0;\n\n    while (spliceCount < eventsCount) {\n      if (now - _events[spliceCount].time < _windowTime) {\n        break;\n      }\n\n      spliceCount++;\n    }\n\n    if (eventsCount > _bufferSize) {\n      spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n    }\n\n    if (spliceCount > 0) {\n      _events.splice(0, spliceCount);\n    }\n\n    return _events;\n  };\n\n  return ReplaySubject;\n}(Subject);\n\nexport { ReplaySubject };\n\nvar ReplayEvent = /*@__PURE__*/function () {\n  function ReplayEvent(time, value) {\n    this.time = time;\n    this.value = value;\n  }\n\n  return ReplayEvent;\n}();","map":{"version":3,"mappings":";AAAA,OAAO,KAAEA,OAAT,MAAwB,OAAxB;AAEA,SAASC,OAAT,QAAsB,WAAtB;AAEA,SAASC,KAAT,QAAqB,mBAArB;AACA,SAASC,YAAT,QAA4B,gBAA5B;AACA,SAASC,mBAAT,QAAkC,uBAAlC;AACA,SAASC,uBAAT,QAAoC,gCAApC;AAQA;;IAAsCC,uCAAUC,MAAV,EAAU;EAM9CP,iCAAyDO,MAAzD;;WAAYD,sCAAqBE,WAAO;IAC5B;MADZC,UAGE,2BAHF;IAEoB;;IAPZ,cAAO,KAA8B,MAArC,EAAqC;MAGrCC;IAMN;;IACA,SAAK,SAAW,KAAX,CAAc,IAAd,KAA2B,IAAhC;;IAEAC,KAAI,UAAJ,GAAcH,SAAd;SACE,WAAK;SACL,uBAAiB;SAClB;SAAM;;QACLE,UAAS,KAAGE,MAAK,oBAAe;MACjCD;;IACF,OAEO;MACFA,KAAK,CAACE,IAAN,GAAMF,KAAW,eAAjB;;;WAEFA;;;eAIE,WAAQG,yBAAQ;SACjB;MACF;;MACDC,aAAMC,KAAN;;MACD;QAEOD;MACD;;;UAEH,WAAKF,gBAAwBG;;;eAE/B,WAAMC,iBAAK,UAAOD,KAAP,EAAO;IACnB;MAGD,uCAAWE,OAAX,IAAoCF,KAApC;;MAEQ;IACN;;IACAT,MAAM,UAAN,CAAkBM,IAAlB,CAAuBM,IAAvB,CAAuB,IAAvB,EAAiCH,KAAjC;;;eAEI,WAA2BI;IAE/B,IAAIC,mBAAa,2BAAjB;;QACEN,OAAM,GAAIM,2BAA0BN,OAA1B,GAA0B;;QACrCP;WAAM,GAAIO,OAAK;QACdO;;QACD;YAAM;WAEL,sBAAmB,aAAnB,EAAsC;MACvCA;IAED,CAHE,MAIA;MACD;MAEGA,mBAAmBC,mBAAnB,CAAqB,IAArB,EAAqBC,UAArB;;;mBAEA;gBACD;IACF;;6BAAM;MACL,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGC,GAAJ,IAAW,CAACF,UAAU,CAACG,MAAvC,EAA+CF,CAAC,EAAhD,EAAoD;QAClDD,UAAU,CAACX,IAAX,CAAiCE,OAAO,CAACU,CAAD,CAAxC;MACD;IACF,OAEG;MACF,UAAU,GAAC,CAAX,EAAgBA,CAAC,MAAD,IAAM,WAAa,OAAnC,EAAmCA,GAAnC,EAAmC;QACpCD;MAAM;;;QAEN;MAEDA,UAAO,MAAP,CAAoB,gBAApB;IACD,OAED;MACEA,UAAa,SAAb;IACD;;IAEO;;;eAEA,WAAcN,UAAK,YAAY;IACrC,OAAM,mBAAmBhB,KAAnB,EAAmB0B,GAAnB,EAAN;;;eAGM,WAAcC,2BAAe;IACnC,IAAID,WAAWV,OAAX,EAAJ;;IAKA,eAAO,GAAW,KAAGY,WAArB;QACEC,WAAW,QAAQA;eACjB,GAAM;mBACP;QACDC,WAAW,GAAG;;WACfA;MAEG,UAAWjB,OAAG,aAAH,CAAgBkB,IAA3B,GAA2BF,WAA3B,EAA2B;QAC7B;MACD;;MAEGC,WAAW;;;QAEdE;MAEDF,WAAe,mDAAf;IACD;;IAEH,kBAAC,CAAD,EAAC;MAAAjB;;;IAED;EACE;;SAAmBT;CAxHiB;;SAyHnCA;;IACH6B,2BAAC;EAHD,SAGCA,WAHD,CAGCF,IAHD,EAGCjB,KAHD,EAGC;;;;;;CAAA","names":["tslib_1","Subject","queue","Subscription","ObserveOnSubscriber","ObjectUnsubscribedError","ReplaySubject","_super","scheduler","bufferSize","windowTime","_this","Number","next","nextInfiniteTimeWindow","_events","value","nextTimeWindow","_getNow","call","_subscribe","_infiniteTimeWindow","subscription","SubjectSubscription","subscriber","i","len","closed","now","_trimBufferThenGetEvents","_bufferSize","_windowTime","spliceCount","time","eventsCount","ReplayEvent"],"sources":["/home/rybakisa/Desktop/TEMP/HackaTON/TON Ads/ton-ads/node_modules/rxjs/src/internal/ReplaySubject.ts"],"sourcesContent":["import { Subject } from './Subject';\nimport { SchedulerLike } from './types';\nimport { queue } from './scheduler/queue';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { ObserveOnSubscriber } from './operators/observeOn';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { SubjectSubscription } from './SubjectSubscription';\n/**\n * A variant of Subject that \"replays\" or emits old values to new subscribers.\n * It buffers a set number of values and will emit those values immediately to\n * any new subscribers in addition to emitting new values to existing subscribers.\n *\n * @class ReplaySubject<T>\n */\nexport class ReplaySubject<T> extends Subject<T> {\n  private _events: (ReplayEvent<T> | T)[] = [];\n  private _bufferSize: number;\n  private _windowTime: number;\n  private _infiniteTimeWindow: boolean = false;\n\n  constructor(bufferSize: number = Number.POSITIVE_INFINITY,\n              windowTime: number = Number.POSITIVE_INFINITY,\n              private scheduler?: SchedulerLike) {\n    super();\n    this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n    this._windowTime = windowTime < 1 ? 1 : windowTime;\n\n    if (windowTime === Number.POSITIVE_INFINITY) {\n      this._infiniteTimeWindow = true;\n      this.next = this.nextInfiniteTimeWindow;\n    } else {\n      this.next = this.nextTimeWindow;\n    }\n  }\n\n  private nextInfiniteTimeWindow(value: T): void {\n    if (!this.isStopped) {\n      const _events = this._events;\n      _events.push(value);\n      // Since this method is invoked in every next() call than the buffer\n      // can overgrow the max size only by one item\n      if (_events.length > this._bufferSize) {\n        _events.shift();\n      }\n    }\n    super.next(value);\n  }\n\n  private nextTimeWindow(value: T): void {\n    if (!this.isStopped) {\n      this._events.push(new ReplayEvent(this._getNow(), value));\n      this._trimBufferThenGetEvents();\n    }\n    super.next(value);\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<T>): Subscription {\n    // When `_infiniteTimeWindow === true` then the buffer is already trimmed\n    const _infiniteTimeWindow = this._infiniteTimeWindow;\n    const _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();\n    const scheduler = this.scheduler;\n    const len = _events.length;\n    let subscription: Subscription;\n\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    } else if (this.isStopped || this.hasError) {\n      subscription = Subscription.EMPTY;\n    } else {\n      this.observers.push(subscriber);\n      subscription = new SubjectSubscription(this, subscriber);\n    }\n\n    if (scheduler) {\n      subscriber.add(subscriber = new ObserveOnSubscriber<T>(subscriber, scheduler));\n    }\n\n    if (_infiniteTimeWindow) {\n      for (let i = 0; i < len && !subscriber.closed; i++) {\n        subscriber.next(<T>_events[i]);\n      }\n    } else {\n      for (let i = 0; i < len && !subscriber.closed; i++) {\n        subscriber.next((<ReplayEvent<T>>_events[i]).value);\n      }\n    }\n\n    if (this.hasError) {\n      subscriber.error(this.thrownError);\n    } else if (this.isStopped) {\n      subscriber.complete();\n    }\n\n    return subscription;\n  }\n\n  _getNow(): number {\n    return (this.scheduler || queue).now();\n  }\n\n  private _trimBufferThenGetEvents(): ReplayEvent<T>[] {\n    const now = this._getNow();\n    const _bufferSize = this._bufferSize;\n    const _windowTime = this._windowTime;\n    const _events = <ReplayEvent<T>[]>this._events;\n\n    const eventsCount = _events.length;\n    let spliceCount = 0;\n\n    // Trim events that fall out of the time window.\n    // Start at the front of the list. Break early once\n    // we encounter an event that falls within the window.\n    while (spliceCount < eventsCount) {\n      if ((now - _events[spliceCount].time) < _windowTime) {\n        break;\n      }\n      spliceCount++;\n    }\n\n    if (eventsCount > _bufferSize) {\n      spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n    }\n\n    if (spliceCount > 0) {\n      _events.splice(0, spliceCount);\n    }\n\n    return _events;\n  }\n\n}\n\nclass ReplayEvent<T> {\n  constructor(public time: number, public value: T) {\n  }\n}\n"]},"metadata":{},"sourceType":"module"}