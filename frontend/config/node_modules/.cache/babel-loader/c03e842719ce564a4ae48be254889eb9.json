{"ast":null,"code":"const {\n  Cell\n} = require(\"../../boc\");\n\nconst {\n  Address,\n  BN,\n  toNano,\n  bytesToHex,\n  hexToBytes,\n  nacl,\n  stringToBytes,\n  bytesToBase64,\n  base64ToBytes\n} = require(\"../../utils\");\n\nconst {\n  Contract\n} = require(\"../index.js\");\n\nconst {\n  WalletContract\n} = require(\"../wallet/WalletContract\");\n\nconst WALLET_ID_BASE = 698983191;\n\nclass LockupWalletV1 extends WalletContract {\n  /**\n   * @param provider    {HttpProvider}\n   * @param options {{publicKey?: Uint8Array, address?: Address | string, wc?: number, config: any}}\n   *\n   * Config json is {config}\n   */\n  constructor(provider, options) {\n    // options.config:\n    // {\n    //     wallet_type: \"lockup-0.1\",\n    //     config_pubkey: <base64-encoded pubkey>,\n    //     allowed_destinations: [ \"addr1\", \"addr2\", ... ]\n    // }\n    options.code = Cell.oneFromBoc(\"B5EE9C7241021E01000261000114FF00F4A413F4BCF2C80B010201200203020148040501F2F28308D71820D31FD31FD31F802403F823BB13F2F2F003802251A9BA1AF2F4802351B7BA1BF2F4801F0BF9015410C5F9101AF2F4F8005057F823F0065098F823F0062071289320D74A8E8BD30731D4511BDB3C12B001E8309229A0DF72FB02069320D74A96D307D402FB00E8D103A4476814154330F004ED541D0202CD0607020120131402012008090201200F100201200A0B002D5ED44D0D31FD31FD3FFD3FFF404FA00F404FA00F404D1803F7007434C0C05C6C2497C0F83E900C0871C02497C0F80074C7C87040A497C1383C00D46D3C00608420BABE7114AC2F6C2497C338200A208420BABE7106EE86BCBD20084AE0840EE6B2802FBCBD01E0C235C62008087E4055040DBE4404BCBD34C7E00A60840DCEAA7D04EE84BCBD34C034C7CC0078C3C412040DD78CA00C0D0E00130875D27D2A1BE95B0C60000C1039480AF00500161037410AF0050810575056001010244300F004ED540201201112004548E1E228020F4966FA520933023BB9131E2209835FA00D113A14013926C21E2B3E6308003502323287C5F287C572FFC4F2FFFD00007E80BD00007E80BD00326000431448A814C4E0083D039BE865BE803444E800A44C38B21400FE809004E0083D10C06002012015160015BDE9F780188242F847800C02012017180201481B1C002DB5187E006D88868A82609E00C6207E00C63F04EDE20B30020158191A0017ADCE76A268699F98EB85FFC00017AC78F6A268698F98EB858FC00011B325FB513435C2C7E00017B1D1BE08E0804230FB50F620002801D0D3030178B0925B7FE0FA4031FA403001F001A80EDAA4\");\n    super(provider, options);\n    if (!this.options.walletId) this.options.walletId = WALLET_ID_BASE + this.options.wc;\n    this.methods.getPublicKey = this.getPublicKey.bind(this);\n    this.methods.getWalletId = this.getWalletId.bind(this);\n    this.methods.getLiquidBalance = this.getLiquidBalance.bind(this);\n    this.methods.getNominalRestrictedBalance = this.getNominalRestrictedBalance.bind(this);\n    this.methods.getNominalLockedBalance = this.getNominalLockedBalance.bind(this);\n  }\n\n  getName() {\n    return 'lockup-0.1';\n  }\n  /**\n   * @override\n   * @private\n   * @param   seqno?   {number}\n   * @param   withoutOp? {boolean}\n   * @return {Cell}\n   */\n\n\n  createSigningMessage(seqno, withoutOp) {\n    seqno = seqno || 0;\n    const message = new Cell();\n    message.bits.writeUint(this.options.walletId, 32);\n\n    if (seqno === 0) {\n      // message.bits.writeInt(-1, 32);// todo: dont work\n      for (let i = 0; i < 32; i++) {\n        message.bits.writeBit(1);\n      }\n    } else {\n      const date = new Date();\n      const timestamp = Math.floor(date.getTime() / 1e3);\n      message.bits.writeUint(timestamp + 60, 32);\n    }\n\n    message.bits.writeUint(seqno, 32);\n    return message;\n  }\n  /**\n   * @override\n   * @return {Cell} cell contains wallet data\n   */\n\n\n  createDataCell() {\n    // from restricted.fc:\n    // .store_int(seqno, 32)\n    // .store_int(subwallet_id, 32)\n    // .store_uint(public_key, 256)\n    // .store_uint(config_public_key, 256)\n    // .store_dict(allowed_destinations)\n    // .store_grams(total_locked_value)\n    // .store_dict(locked)\n    // .store_grams(total_restricted_value)\n    // .store_dict(restricted).end_cell();\n    const cell = new Cell();\n    cell.bits.writeUint(0, 32); // seqno\n\n    cell.bits.writeUint(this.options.walletId, 32);\n    cell.bits.writeBytes(this.options.publicKey); // TODO: write config.config_public_key (need to sort out encoding - the params come in base64),\n    // TODO: write the dict of allowed destinations (address is a key to an empty value).\n\n    cell.bits.writeBytes(base64ToBytes(this.options.config.config_public_key));\n\n    if (this.options.config.allowed_destinations) {\n      cell.bits.writeUint(1, 1);\n      cell.refs.push(Cell.oneFromBoc(base64ToBytes(this.options.config.allowed_destinations)));\n    } else {\n      cell.bits.writeUint(0, 1);\n    }\n\n    cell.bits.writeGrams(0); // .store_grams(total_locked_value)\n\n    cell.bits.writeUint(0, 1); // empty locked dict\n\n    cell.bits.writeGrams(0); // .store_grams(total_restricted_value)\n\n    cell.bits.writeUint(0, 1); // empty locked dict\n\n    return cell;\n  }\n  /**\n   * @return {Promise<number>}\n   */\n\n\n  async getWalletId() {\n    const myAddress = await this.getAddress();\n    const id = await this.provider.call2(myAddress.toString(), 'get_subwallet_id');\n    return id.toNumber();\n  }\n  /**\n   * @return {Promise<BN>}\n   */\n\n\n  async getPublicKey() {\n    const myAddress = await this.getAddress();\n    return this.provider.call2(myAddress.toString(), 'get_public_key');\n  }\n  /**\n   * @return {Promise<BN>} Amount of nanotoncoins that can be spent immediately.\n   */\n\n\n  async getLiquidBalance() {\n    const balances = await this.getBalances();\n    return balances[0] - balances[1] - balances[2];\n  }\n  /**\n   * @return {Promise<BN>} Amount of nanotoncoins that can be spent after the timelock OR to the whitelisted addresses.\n   */\n\n\n  async getNominalRestrictedBalance() {\n    return await this.getBalances()[1];\n  }\n  /**\n   * @return {Promise<BN>} Amount of nanotoncoins that can be spent after the timelock only (whitelisted addresses not used).\n   */\n\n\n  async getNominalLockedBalance() {\n    return await this.getBalances()[2];\n  }\n  /**\n   * @return {Promise<[BN,BN,BN]>} Total amount of nanotoncoins on the contract,\n   * nominal restricted value\n   * nominal locked value\n   */\n\n\n  async getBalances() {\n    const myAddress = await this.getAddress();\n    return this.provider.call2(myAddress.toString(), 'get_balances');\n  }\n\n}\n\nmodule.exports.default = {\n  LockupWalletV1,\n  all: {\n    'lockup-0.1': LockupWalletV1\n  },\n  list: [LockupWalletV1]\n};","map":{"version":3,"names":["Cell","require","Address","BN","toNano","bytesToHex","hexToBytes","nacl","stringToBytes","bytesToBase64","base64ToBytes","Contract","WalletContract","WALLET_ID_BASE","LockupWalletV1","constructor","provider","options","code","oneFromBoc","walletId","wc","methods","getPublicKey","bind","getWalletId","getLiquidBalance","getNominalRestrictedBalance","getNominalLockedBalance","getName","createSigningMessage","seqno","withoutOp","message","bits","writeUint","i","writeBit","date","Date","timestamp","Math","floor","getTime","createDataCell","cell","writeBytes","publicKey","config","config_public_key","allowed_destinations","refs","push","writeGrams","myAddress","getAddress","id","call2","toString","toNumber","balances","getBalances","module","exports","default","all","list"],"sources":["/home/rybakisa/Desktop/TEMP/HackaTON/TON Ads/ton-ads/node_modules/tonweb/src/contract/lockup/index.js"],"sourcesContent":["const {Cell} = require(\"../../boc\");\nconst {Address, BN, toNano, bytesToHex, hexToBytes, nacl, stringToBytes, bytesToBase64, base64ToBytes} = require(\"../../utils\");\nconst {Contract} = require(\"../index.js\");\nconst {WalletContract} = require(\"../wallet/WalletContract\");\n\nconst WALLET_ID_BASE = 698983191;\n\nclass LockupWalletV1 extends WalletContract {\n\n    /**\n     * @param provider    {HttpProvider}\n     * @param options {{publicKey?: Uint8Array, address?: Address | string, wc?: number, config: any}}\n     *\n     * Config json is {config}\n     */\n    constructor(provider, options) {\n        // options.config:\n        // {\n        //     wallet_type: \"lockup-0.1\",\n        //     config_pubkey: <base64-encoded pubkey>,\n        //     allowed_destinations: [ \"addr1\", \"addr2\", ... ]\n        // }\n\n        options.code = Cell.oneFromBoc(\"B5EE9C7241021E01000261000114FF00F4A413F4BCF2C80B010201200203020148040501F2F28308D71820D31FD31FD31F802403F823BB13F2F2F003802251A9BA1AF2F4802351B7BA1BF2F4801F0BF9015410C5F9101AF2F4F8005057F823F0065098F823F0062071289320D74A8E8BD30731D4511BDB3C12B001E8309229A0DF72FB02069320D74A96D307D402FB00E8D103A4476814154330F004ED541D0202CD0607020120131402012008090201200F100201200A0B002D5ED44D0D31FD31FD3FFD3FFF404FA00F404FA00F404D1803F7007434C0C05C6C2497C0F83E900C0871C02497C0F80074C7C87040A497C1383C00D46D3C00608420BABE7114AC2F6C2497C338200A208420BABE7106EE86BCBD20084AE0840EE6B2802FBCBD01E0C235C62008087E4055040DBE4404BCBD34C7E00A60840DCEAA7D04EE84BCBD34C034C7CC0078C3C412040DD78CA00C0D0E00130875D27D2A1BE95B0C60000C1039480AF00500161037410AF0050810575056001010244300F004ED540201201112004548E1E228020F4966FA520933023BB9131E2209835FA00D113A14013926C21E2B3E6308003502323287C5F287C572FFC4F2FFFD00007E80BD00007E80BD00326000431448A814C4E0083D039BE865BE803444E800A44C38B21400FE809004E0083D10C06002012015160015BDE9F780188242F847800C02012017180201481B1C002DB5187E006D88868A82609E00C6207E00C63F04EDE20B30020158191A0017ADCE76A268699F98EB85FFC00017AC78F6A268698F98EB858FC00011B325FB513435C2C7E00017B1D1BE08E0804230FB50F620002801D0D3030178B0925B7FE0FA4031FA403001F001A80EDAA4\");\n        super(provider, options);\n        if (!this.options.walletId) this.options.walletId = WALLET_ID_BASE + this.options.wc;\n\n        this.methods.getPublicKey = this.getPublicKey.bind(this);\n        this.methods.getWalletId = this.getWalletId.bind(this);\n        this.methods.getLiquidBalance = this.getLiquidBalance.bind(this);\n        this.methods.getNominalRestrictedBalance = this.getNominalRestrictedBalance.bind(this);\n        this.methods.getNominalLockedBalance = this.getNominalLockedBalance.bind(this);\n    }\n\n    getName() {\n        return 'lockup-0.1';\n    }\n\n    /**\n     * @override\n     * @private\n     * @param   seqno?   {number}\n     * @param   withoutOp? {boolean}\n     * @return {Cell}\n     */\n    createSigningMessage(seqno, withoutOp) {\n        seqno = seqno || 0;\n        const message = new Cell();\n        message.bits.writeUint(this.options.walletId, 32);\n        if (seqno === 0) {\n            // message.bits.writeInt(-1, 32);// todo: dont work\n            for (let i = 0; i < 32; i++) {\n                message.bits.writeBit(1);\n            }\n        } else {\n            const date = new Date();\n            const timestamp = Math.floor(date.getTime() / 1e3);\n            message.bits.writeUint(timestamp + 60, 32);\n        }\n        message.bits.writeUint(seqno, 32);\n        return message;\n    }\n\n    /**\n     * @override\n     * @return {Cell} cell contains wallet data\n     */\n    createDataCell() {\n        // from restricted.fc:\n        // .store_int(seqno, 32)\n        // .store_int(subwallet_id, 32)\n        // .store_uint(public_key, 256)\n        // .store_uint(config_public_key, 256)\n        // .store_dict(allowed_destinations)\n        // .store_grams(total_locked_value)\n        // .store_dict(locked)\n        // .store_grams(total_restricted_value)\n        // .store_dict(restricted).end_cell();\n\n        const cell = new Cell();\n        cell.bits.writeUint(0, 32); // seqno\n        cell.bits.writeUint(this.options.walletId, 32);\n        cell.bits.writeBytes(this.options.publicKey);\n\n        // TODO: write config.config_public_key (need to sort out encoding - the params come in base64),\n        // TODO: write the dict of allowed destinations (address is a key to an empty value).\n        cell.bits.writeBytes(base64ToBytes(this.options.config.config_public_key));\n        if (this.options.config.allowed_destinations) {\n            cell.bits.writeUint(1, 1);\n            cell.refs.push(Cell.oneFromBoc(base64ToBytes(this.options.config.allowed_destinations)));\n        } else {\n            cell.bits.writeUint(0, 1);\n        }\n\n        cell.bits.writeGrams(0);   // .store_grams(total_locked_value)\n        cell.bits.writeUint(0, 1); // empty locked dict\n        cell.bits.writeGrams(0);   // .store_grams(total_restricted_value)\n        cell.bits.writeUint(0, 1); // empty locked dict\n        return cell;\n    }\n\n    /**\n     * @return {Promise<number>}\n     */\n    async getWalletId() {\n        const myAddress = await this.getAddress();\n        const id = await this.provider.call2(myAddress.toString(), 'get_subwallet_id');\n        return id.toNumber();\n    }\n\n    /**\n     * @return {Promise<BN>}\n     */\n    async getPublicKey() {\n        const myAddress = await this.getAddress();\n        return this.provider.call2(myAddress.toString(), 'get_public_key');\n    }\n\n\n    /**\n     * @return {Promise<BN>} Amount of nanotoncoins that can be spent immediately.\n     */\n    async getLiquidBalance() {\n        const balances = await this.getBalances();\n        return balances[0]-balances[1]-balances[2];\n    }\n    /**\n     * @return {Promise<BN>} Amount of nanotoncoins that can be spent after the timelock OR to the whitelisted addresses.\n     */\n     async getNominalRestrictedBalance() {\n        return await this.getBalances()[1];\n    }\n\n    /**\n     * @return {Promise<BN>} Amount of nanotoncoins that can be spent after the timelock only (whitelisted addresses not used).\n     */\n     async getNominalLockedBalance() {\n        return await this.getBalances()[2];\n    }\n    /**\n     * @return {Promise<[BN,BN,BN]>} Total amount of nanotoncoins on the contract,\n     * nominal restricted value\n     * nominal locked value\n     */\n     async getBalances() {\n        const myAddress = await this.getAddress();\n        return this.provider.call2(myAddress.toString(), 'get_balances');\n    }\n}\n\nmodule.exports.default = {\n    LockupWalletV1,\n    all: {\n        'lockup-0.1': LockupWalletV1,\n    },\n    list: [LockupWalletV1]\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}